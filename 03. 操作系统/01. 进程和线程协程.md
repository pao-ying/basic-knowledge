# 进程与线程

## 定义

进程是系统进行**资源分配和调度**的基本单位。

线程是**CPU调度和分派**的基本单位。

## 关系

一个进程可以有多个线程，多个线程之间可以并发执行。

多个进程间是相互独立的，但是同一进程下的线程可能会相互影响。

## 比较

- 开销

  进程创建和销毁，系统都需要为之**分配和回收资源**，导致系统的开销要大于线程的开销。

- 调度

  进程作为资源分配的基本单位，线程作为CPU调度的基本单位

- 并发性

  进程间可以并发执行，进程间也可以并发执行

- 拥有资源

  进程是系统中拥有资源的基本单位，线程不拥有资源，但可以访问隶属的进程资源。

# 进程有几种状态

- 创建状态

- 就绪状态

  获得了除CPU以外的所有资源

- 运行状态

- 阻塞状态

  进程正在等待某一事件完成，如等待某一资源可用或者等待IO操作。即使CPU空闲，也不能使用。

- 结束状态

  进程从系统消失。如进程正常结束或中断退出。

# 进程间的通信方式

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为**进程间通信（IPC，InterProcess Communication）**

- 管道/匿名管道

  他是**半双工**的，即数据只能在一个方向上流动，具有固定的读端和写端。同时管道的实质是**内核缓冲区**，管道一段的进程将数据写入缓冲区，另一端的进程从缓冲区读取数据，且两个进程必须是**父子进程**或者**兄弟进程**。

- 命名管道

  命名管道和管道的区别就是有名字，这个名字对应一个**磁盘索引文件**，通过这个文件，任何进程都可以访问该管道，从而实现本机内任意两个进程通信。

- 信号

  用于通知进程某个事件已经发生。

  - 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
  - 如果该进程当前并未处于**执行状态**，则该信号就有内核保存起来，知道该进程恢复执行并传递给它为止。
  - 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。 

- 消息队列

  - 消息队列是一系列保存在**内核**中消息的链表（匿名管道是存在于内存中的文件，命名管道是磁盘介质或者文件系统），只有在内核重启或者显示的删除一个消息队列时，该消息队列才会被真正的删除。

  - 进程可以向消息队列中添加消息，也可以读取消息。消息队列与管道的不同是，消息队列可以实现消息的随机查询，不一定按先进先出次序读取，消息都有指定的**消息类型**，进程在接收时可以根据自己的需求接收特定的消息。

- 信号量

  信号量是一个**计数器**，主要用于进程间对**共享数据**的访问和**进程同步**。它的实现是基于操作系统的 PV 操作。

  为了获得共享资源，进程需要执行如下操作：

  - 创建一个信号量，通常是1，也可以是0
  - 等待一个信号量，该操作会检测信号量的值，如果小于0，就阻塞，称为P操作
  - 挂出一个信号，该操作会将信号量的值+1，也称为V操作

  信号量与互斥量区别：

  - 互斥量用于线程的互斥，信号量用于线程的同步。这是根本区别

    **互斥：**是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

    **同步：**是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。

  - 互斥量值只能为0/1，信号量值可以为非负整数。

    一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。

  - 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。

- 共享内存

  - 共享内存允许多个进程共享一块内存空间，内核专门留出了一块内存区，可以被进程**映射**到自己的进程空间中。共享内存的好处就是效率高，进程可以直接读取内存，而不需要进行内核空间和用户空间的数据拷贝。
  - 由于多个进程共享一段内存，因此需要依靠某种同步机制（如**信号量**）来达到进程间的同步及互斥。

- 套接字

  套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点。
  
  **套接字特性**
  
  - 套接字的域：
  
    它指定套接字通信中使用的**网络介质**，最常见的套接字域有两种：
  
    - 一种是**AF_INET**，指的是Internet介质。当使用套接字进行跨网络通信时，需要用到IP地址与端口指定一台服务器的特定服务。
  
    - 一种是**AF_UNIX**，表示的是UNIX文件系统。它就是文件输入/输出，而它的地址就是文件名。
  
  - 套接字端口号
  
    端口号即**信息缓冲区**，用于保留Socket中的输入/输出信息
  
  - 套接字协议类型
  
    Internet 提供三种通信机制
  
    - **流套接字**，流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。
    - **数据包套接字**，它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。
    - **原始套接字**，原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现。
  
    > **原始套接字与标准套接字的区别在于：**
    >  原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。

https://www.jianshu.com/p/c1015f5ffa74

https://blog.csdn.net/zhaohong_bo/article/details/89552188

# 进程同步机制

- 临界区

  通过对多线程的**串形化**来访问公共资源或一段代码，速度快，适合控制数据访问

  **优点**

  保证同一时刻只有一个线程能够进入临界区

  **缺点**

  只能同步**本进程内的线程**，而不可用于同步不同进程内的线程

- 互斥量

  采用互斥对象机制，只有拥有互斥对象的线程才能对公共资源进行访问，由于互斥对象只有一个，所以能够保证公共资源不会被多线程访问。

  **优点**

  互斥不仅能实现同一应用程序的公共资源安全共享，还能实现**不同应用程序**的公共资源安全共享 ，即夸进程同步。

  **缺点**

  互斥量是可以命名的，所以可以跨进程访问，但是创建互斥量会带来更多的资源消耗，同时只支持一个线程访问公共资源。

- 信号量

  允许同一时刻**多个**线程对共享资源进行访问，但需要控制同一时刻访问该资源的最大线程量。

  **优点**

  适用于对 Socket 程序中的线程同步（跨进程同步），如可以限制同一时间同时访问的数量。

  **缺点**

  - 信号量必须有公共内存，不能用于分布式。
  - 读写和维和很困难

- 事件

  wait/notify。用来通知线程有一些事件已经发生，从而启动后续任务的开始。

# 进程的调度算法

周转时间 = 任务结束时间 - 任务到达时间

1. **先来先服务调度算法**

   哪个任务先来，就先服务。会造成很多短任务即使服务时间短，但是它们的周转时间都比较长。

2. **短作业优先调度算法**

   哪个任务的服务时间短就先调度哪个。关注的是**平均周转时间**

3. **高相应比优先调度算法**

   权衡了短作业和长作业。优先权=（等待时间+服务时间）/ 服务时间

   > 如两个进程的等待时间相同，则服务时间越短，相应比越高，短作业容易选中；
   >
   > 如哦两个进程的服务时间相同，则等待时间越长，相应比越高，长作业容易选中

4. **时间片轮转调度算法**

   设置一个时间片，每个进程都执行相同的时间。关注的是**响应时间**

4. **最高优先级调度算法**

   进程的优先级可以分为，**静态优先级或动态优先级：**

   - 静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；
   - 动态优先级：根据进程的动态变化调整优先级

   两种处理优先级高的方法，**非抢占式和抢占式**

   - 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。
   - 抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。

5. **多级反馈队列调度算法**

   - 「多级」表示有多个队列，每个队列优先级从高到低，同时**优先级越高时间片越短。**
   - 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去**运行优先级高的队列**；

   工作方式：

   - 设置了多个队列，赋予每个队列不同的优先级，每个**队列优先级从高到低**，同时**优先级越高时间片越短**；
   - 新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；
   - 当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；

# 协程

## 是什么

协程（Coroutine）是**用户态的线程**。通常创建协程时，会从进程的堆中分配一段内存作为协程的栈。

线程的栈有 8 MB，而协程栈的大小通常只有 KB，而 Go 语言的协程更夸张，只有 2-4KB，非常的轻巧。

## 优势

- **节省 CPU**：避免系统**内核级**的线程频繁切换，造成的 CPU 资源浪费。好钢用在刀刃上。而协程是用户态的线程，用户可以自行控制协程的创建于销毁，极大程度避免了系统级线程上下文切换造成的资源浪费。
- **节约内存**：在 64 位的Linux中，一个线程需要分配 8MB 栈内存和 64MB 堆内存，系统内存的制约导致我们无法开启更多线程实现高并发。而在协程编程模式下，可以轻松有十几万协程，这是线程无法比拟的。
- **稳定性**：前面提到线程之间通过内存来共享数据，这也导致了一个问题，任何一个线程出错时，进程中的所有线程都会跟着一起崩溃。
- **开发效率**：使用协程在开发程序之中，可以很方便的将一些耗时的IO操作异步化，例如写文件、耗时 IO 请求等。

# 适用场景

## 进程

多进程适合在**CPU 密集型操作(cpu 操作指令比较多，计算密集型，如科学计算，位数多的浮点运算)**
计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。
计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。

## 线程

多线程适合在**IO 密集型操作(读写数据操作较多的，比如爬虫)**
IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。

IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。

## 协程

Python中的多线程是假的多线程，协程+线程=真的多线程
