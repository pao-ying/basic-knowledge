# 进程与线程

## 定义

进程是系统进行资源**分配和调度**的基本单位。

线程是CPU**调度和分派**的基本单位。

## 关系

一个进程可以有多个线程，多个线程之间可以并发执行。

多个进程间是相互独立的，但是同一进程下的线程可能会相互影响。

## 比较

- 开销

  进程创建和销毁，系统都需要为之**分配和回收资源**，导致系统的开销要大于线程的开销。

- 调度

  进程作为资源分配的基本单位，线程作为CPU调度的基本单位

- 并发性

  进程间可以并发执行，进程间也可以并发执行

- 拥有资源

  进程是系统中拥有资源的基本单位，线程不拥有资源，但可以访问隶属的进程资源。

# 进程有几种状态

- 创建状态

- 就绪状态

  获得了除CPU以外的所有资源

- 运行状态

- 阻塞状态

  进程正在等待某一事件完成，如等待某一资源可用或者等待IO操作。即使CPU空闲，也不能使用。

- 结束状态

  进程从系统消失。如进程正常结束或中断退出。

# 进程间的通信方式

- 管道/匿名管道

  他是半双工的，即数据只能在一个方向上流动，具有固定的读端和写端。同时管道的实质是**内核缓冲区**，管道一段的进程将数据写入缓冲区，另一端的进程从缓冲区读取数据，且两个进程必须是父子进程或者兄弟进程。

- 命名管道

  命名管道和管道的区别就是有名字，这个名字对应一个**磁盘索引文件**，通过这个文件，任何进程都可以访问该管道，从而实现本机内任意两个进程通信。

- 信号

  用于通知进程某个事件已经发生。

- 消息队列

  消息队列是一系列保存在内核中消息的列表，进程可以向消息队列中添加消息，也可以读取消息。消息队列与管道的不同是，消息都有指定的**消息类型**，进程在接收时可以根据自己的需求接收特定的消息。

- 信号量

  信号量是一个**计数器**，主要用于进程间对**共享数据**的访问和进程同步。它的实现是基于操作系统的 PV 操作。

- 共享内存

  共享内存允许多个进程共享一块存储区域，这块存储区域可以被进程**映射**到自己的进程空间中。共享内存的好处就是效率高，进程可以直接读取内存，而不需要进行内核空间和用户空间的数据拷贝。

- 套接字

  主要用于客户端和服务器直接进行通信。

https://blog.csdn.net/zhaohong_bo/article/details/89552188

# 进程同步机制

多进程下访问资源。

- 互斥量

  采用互斥对象机制，只有拥有互斥对象的线程才能对公共资源进行访问，由于互斥对象只有一个，所以能够保证公共资源不会被多线程访问。

- 信号量

  允许同一时刻**多个**线程对共享资源进行访问，但需要控制同一时刻访问该资源的最大线程量

- 事件

  wait/notify。通过通知等待的方式来保持进程同步。

# 进程的调度算法

周转时间 = 任务结束时间 - 任务到达时间

1. **先来先服务调度算法**

   哪个任务先来，就先服务。会造成很多短任务即使服务时间短，但是它们的周转时间都比较长。

2. **短作业优先调度算法**

   哪个任务的服务时间短就先调度哪个。关注的是**平均周转时间**

3. **高相应比优先调度算法**

   权衡了短作业和长作业。优先权=（等待时间+服务时间）/ 服务时间

   > 如两个进程的等待时间相同，则服务时间越短，相应比越高，短作业容易选中；
   >
   > 如哦两个进程的服务时间相同，则等待时间越长，相应比越高，长作业容易选中

4. **时间片轮转调度算法**

   设置一个时间片，每个进程都执行相同的时间。关注的是**响应时间**

4. **最高优先级调度算法**

   进程的优先级可以分为，**静态优先级或动态优先级：**

   - 静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；
   - 动态优先级：根据进程的动态变化调整优先级

   两种处理优先级高的方法，**非抢占式和抢占式**

   - 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。
   - 抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。

5. **多级反馈队列调度算法**

   - 「多级」表示有多个队列，每个队列优先级从高到低，同时**优先级越高时间片越短。**
   - 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去**运行优先级高的队列**；

   工作方式：

   - 设置了多个队列，赋予每个队列不同的优先级，每个**队列优先级从高到低**，同时**优先级越高时间片越短**；
   - 新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；
   - 当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；

# 协程

## 是什么

协程（Coroutine）是用户态的线程。通常创建协程时，会从进程的堆中分配一段内存作为协程的栈。

线程的栈有 8 MB，而协程栈的大小通常只有 KB，而 Go 语言的协程更夸张，只有 2-4KB，非常的轻巧。

## 优势

- **节省 CPU**：避免系统内核级的线程频繁切换，造成的 CPU 资源浪费。好钢用在刀刃上。而协程是用户态的线程，用户可以自行控制协程的创建于销毁，极大程度避免了系统级线程上下文切换造成的资源浪费。
- **节约内存**：在 64 位的Linux中，一个线程需要分配 8MB 栈内存和 64MB 堆内存，系统内存的制约导致我们无法开启更多线程实现高并发。而在协程编程模式下，可以轻松有十几万协程，这是线程无法比拟的。
- **稳定性**：前面提到线程之间通过内存来共享数据，这也导致了一个问题，任何一个线程出错时，进程中的所有线程都会跟着一起崩溃。
- **开发效率**：使用协程在开发程序之中，可以很方便的将一些耗时的IO操作异步化，例如写文件、耗时 IO 请求等。

# 适用场景

## 进程

多进程适合在**CPU 密集型操作(cpu 操作指令比较多，计算密集型，如科学计算，位数多的浮点运算)**
计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。
计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。

## 线程

多线程适合在**IO 密集型操作(读写数据操作较多的，比如爬虫)**
IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。

IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。

## 协程

Python中的多线程是假的多线程，协程+线程=真的多线程
