# 进程与线程

## 定义

进程是系统进行资源**分配和调度**的基本单位。

线程是CPU**调度和分派**的基本单位。

## 关系

一个进程可以有多个线程，多个线程之间可以并发执行。

多个进程间是相互独立的，但是同一进程下的线程可能会相互影响。

## 比较

- 开销

  进程创建和销毁，系统都需要为之**分配和回收资源**，导致系统的开销要大于线程的开销。

- 调度

  进程作为资源分配的基本单位，线程作为CPU调度的基本单位

- 并发性

  进程间可以并发执行，进程间也可以并发执行

- 拥有资源

  进程是系统中拥有资源的基本单位，线程不拥有资源，但可以访问隶属的进程资源。

## 切换

### 上下文切换

内核为每一个进程维持一个上下文。**上下文就是内核重新启动一个被抢占的进程所需的状态。**包括以下内容：

- 通用目的寄存器
- 浮点寄存器
- 程序计数器
- 用户栈
- 状态寄存器
- 内核栈
- 各种内核数据结构：比如描绘地址空间的页表，包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。

### 进程和线程切换

进程切换就是上下文切换。

> **虚拟内存**
>
> 虚拟内存是操作系统为每个进程提供的一种抽象，每个进程都有属于自己的、私有的、地址连续的虚拟内存，当然我们知道最终进程的数据及代码必然要放到物理内存上，那么必须有某种机制能记住虚拟地址空间中的某个数据被放到了哪个物理内存地址上，这就是所谓的地址空间映射，那么操作系统是如何记住这种映射关系的呢，答案就是页表。
>
> **每个进程都有自己的虚拟地址空间，进程内的所有线程共享进程的虚拟地址空间**。

进程切换和线程切换的区别最主要的一个区别在于**进程切换涉及虚拟地址空间的切换而线程不会**。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。

> 现在我们已经知道了进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是TLB（translation Lookaside Buffer，我们不需要关心这个名字只需要知道TLB本质上就是一个cache，是用来加速页表查找的）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么**当进程切换后页表也要进行切换，页表切换后TLB就失效了**，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。

## 线程共享和独立资源

### 线程共享资源

 1.进程代码段 

 2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯) 

 3.进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。

### 线程独立资源

1. 线程 ID

   每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。

2. 寄存器组的值

   由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。

3. 线程的堆栈

   堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的

   函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。

4. 错误返回码

   由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该 线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。

5. 错误的信号屏蔽码

   由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都 共享同样的信号处理器。

6. 线程的优先级

   由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。

# 进程有几种状态

- 创建状态

- 就绪状态

  获得了除CPU以外的所有资源

- 运行状态

- 阻塞状态

  进程正在等待某一事件完成，如等待某一资源可用或者等待IO操作。即使CPU空闲，也不能使用。

- 结束状态

  进程从系统消失。如进程正常结束或中断退出。

# 进程间的通信方式

- 管道/匿名管道

  他是半双工的，即数据只能在一个方向上流动，具有固定的读端和写端。同时管道的实质是**内核缓冲区**，管道一段的进程将数据写入缓冲区，另一端的进程从缓冲区读取数据，且两个进程必须是父子进程或者兄弟进程。

- 命名管道

  命名管道和管道的区别就是有名字，这个名字对应一个**磁盘索引文件**，通过这个文件，任何进程都可以访问该管道，从而实现本机内任意两个进程通信。

- 信号

  用于通知进程某个事件已经发生。

- 消息队列

  消息队列是一系列保存在内核中消息的列表，进程可以向消息队列中添加消息，也可以读取消息。消息队列与管道的不同是，消息都有指定的**消息类型**，进程在接收时可以根据自己的需求接收特定的消息。

- 信号量

  信号量是一个**计数器**，主要用于进程间对**共享数据**的访问和进程同步。它的实现是基于操作系统的 PV 操作。

- 共享内存

  共享内存允许多个进程共享一块存储区域，这块存储区域可以被进程**映射**到自己的进程空间中。共享内存的好处就是效率高，进程可以直接读取内存，而不需要进行内核空间和用户空间的数据拷贝。

- 套接字

  主要用于客户端和服务器直接进行通信。

https://blog.csdn.net/zhaohong_bo/article/details/89552188

# 进程同步机制

多进程下访问资源。

- 互斥量

  采用互斥对象机制，只有拥有互斥对象的线程才能对公共资源进行访问，由于互斥对象只有一个，所以能够保证公共资源不会被多线程访问。

- 信号量

  允许同一时刻**多个**线程对共享资源进行访问，但需要控制同一时刻访问该资源的最大线程量

- 事件

  wait/notify。通过通知等待的方式来保持进程同步。

# 进程的调度算法

周转时间 = 任务结束时间 - 任务到达时间

1. **先来先服务调度算法**

   哪个任务先来，就先服务。会造成很多短任务即使服务时间短，但是它们的周转时间都比较长。

2. **短作业优先调度算法**

   哪个任务的服务时间短就先调度哪个。关注的是**平均周转时间**

3. **高相应比优先调度算法**

   权衡了短作业和长作业。优先权=（等待时间+服务时间）/ 服务时间

   > 如两个进程的等待时间相同，则服务时间越短，相应比越高，短作业容易选中；
   >
   > 如哦两个进程的服务时间相同，则等待时间越长，相应比越高，长作业容易选中

4. **时间片轮转调度算法**

   设置一个时间片，每个进程都执行相同的时间。关注的是**响应时间**

4. **最高优先级调度算法**

   进程的优先级可以分为，**静态优先级或动态优先级：**

   - 静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；
   - 动态优先级：根据进程的动态变化调整优先级

   两种处理优先级高的方法，**非抢占式和抢占式**

   - 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。
   - 抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。

5. **多级反馈队列调度算法**

   - 「多级」表示有多个队列，每个队列优先级从高到低，同时**优先级越高时间片越短。**
   - 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去**运行优先级高的队列**；

   工作方式：

   - 设置了多个队列，赋予每个队列不同的优先级，每个**队列优先级从高到低**，同时**优先级越高时间片越短**；
   - 新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；
   - 当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；

# 协程

## 是什么

协程（Coroutine）是用户态的线程。通常创建协程时，会从进程的堆中分配一段内存作为协程的栈。

线程的栈有 8 MB，而协程栈的大小通常只有 KB，而 Go 语言的协程更夸张，只有 2-4KB，非常的轻巧。

## 优势

- **节省 CPU**：避免系统内核级的线程频繁切换，造成的 CPU 资源浪费。好钢用在刀刃上。而协程是用户态的线程，用户可以自行控制协程的创建于销毁，极大程度避免了系统级线程上下文切换造成的资源浪费。
- **节约内存**：在 64 位的Linux中，一个线程需要分配 8MB 栈内存和 64MB 堆内存，系统内存的制约导致我们无法开启更多线程实现高并发。而在协程编程模式下，可以轻松有十几万协程，这是线程无法比拟的。
- **稳定性**：前面提到线程之间通过内存来共享数据，这也导致了一个问题，任何一个线程出错时，进程中的所有线程都会跟着一起崩溃。
- **开发效率**：使用协程在开发程序之中，可以很方便的将一些耗时的IO操作异步化，例如写文件、耗时 IO 请求等。

# 适用场景

## 进程

多进程适合在**CPU 密集型操作(cpu 操作指令比较多，计算密集型，如科学计算，位数多的浮点运算)**
计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。
计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。

## 线程

多线程适合在**IO 密集型操作(读写数据操作较多的，比如爬虫)**
IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。

IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。

## 协程

Python中的多线程是假的多线程，协程+线程=真的多线程
