# 基本概念

**内存溢出**：**程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存**，于是就发生了内存溢出。出现 Out of Memory

**内存泄漏**：程序运行过程中**分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存**，既不能被使用也不能分配给其他程序，于是就发生了内存泄漏。出现 Memory Leak，最终也会导致 Out Of Memory

# 内存溢出

常见情况

- **java.lang.OutOfMemoryError: PermGen space (持久带溢出)**

  我们知道jvm通过**持久带实现了java虚拟机规范中的方法区，而运行时常量池就是保存在方法区中的**，因此发生这种溢出可能是运行时常量池溢出，或是由于程序中使用了大量的jar或class，使得方法区中保存的class对象没有被及时回收或者class信息占用的内存超过了配置的大小。

- **java.lang.OutOfMemoryError: Java heap space (堆溢出)**

  发生这种溢出的原因一般是创建的对象太多，在进行垃圾回收之前对象数量达到了最大堆的容量限制。

  解决这个区域异常的方法一般是通过内存映像分析工具对Dump出来的堆转储快照进行分析，看到底是内存溢出还是内存泄漏。如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，定位出泄漏代码的位置，修改程序或算法；如果不存在泄漏，就是说内存中的对象确实都还必须存活，那就应该检查虚拟机的堆参数-Xmx(最大堆大小)和-Xms(初始堆大小)，与机器物理内存对比看是否可以调大。

- **虚拟机栈和本地方法栈溢出**

  如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError。

  如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError。

# 内存泄漏

内存泄漏的根本原因是**长生命周期的对象持有短生命周期对象的引用**，尽管短生命周期的对象已经不再需要，但由于长生命周期对象持有它的引用而导致不能被回收。

**以发生的方式来分类，内存泄漏可以分为4类：** 

- **常发性内存泄漏**

  发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。

- **偶发性内存泄漏**

  发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。

- **一次性内存泄漏**

  发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。

- **隐式内存泄漏**

  程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存 

**下面总结几种常见的内存泄漏：**

- **静态集合类引起的内存泄漏：**

  像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，容易造成内存泄漏，因为他们也将一直被Vector或HashMap等引用着。

- **修改HashSet中对象的参数值，且参数是计算哈希值的字段**

  当一个对象被存储到HashSet集合中以后，修改了这个对象中那些参与计算哈希值的字段后，这个对象的哈希值与最初存储在集合中的就不同了，这种情况下，用contains方法在集合中检索对象是找不到的，这将会导致无法从HashSet中删除当前对象，造成内存泄漏

- **各种连接**

  比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close() 方法将其连接关闭，否则是不会自动被GC 回收的。

- **单例对象**

  如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露。

  不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在JVM的整个生命周期中存在（以**静态变量**的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露

## 避免内存泄漏建议

1、尽早释放无用对象的引用。

2、避免在循环中创建对象。

3、使用字符串处理时避免使用String，应使用StringBuffer。

4、尽量少使用静态变量，因为静态变量存放在永久代，基本不参与垃圾回收。