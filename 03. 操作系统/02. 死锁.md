# 死锁是什么

**多个进程竞争有限的资源**，若一个线程没有可用资源，则进入等待状态。如果占用该资源的线程也再等待其它资源，依次反复形成**循环等待**，称为死锁。

# 死锁四个条件

- 互斥

  一个资源只能被一个进程使用。

- 占有并等待

  一个线程占有一个资源，并且等待另一个资源，而该资源被另一个进程所占用

- 非抢占

  资源不能被抢占，只能在主动释放后才能被分配。

- 循环等待

  一组等待进程，前一个进程等待后一个进程释放资源，后一个期待它后一个释放，依次，最后一个期待第一个释放，形成循环等待。

# 死锁预防

- 破坏“占有并等待”

  - 进程运行前一次分配所有要求的资源
  - 进程提出新的资源申请时，释放它占有的资源

- 破坏“不可抢占”

  - 如果一个进程在申请其他资源时被拒绝，则释放它占有的资源。
  - 如果一个进程申请其他资源被拒绝时，可以抢占该资源。该方法只有在两进程的优先级都不同时有效。

- 破坏“循环等待”

  将系统所有资源进程编号，进程的资源申请都必须按编号顺序提出。

# 死锁避免

在避免死锁的算法中，系统允许进程动态申请资源，但为进程分配资源前，要**先计算这次资源分配的安全性**，如果这次分配不会导致系统进入不安全的状态，则将资源分配给进程，否则让进程等待。

安全状态是指系统能够按照某种序列，来为系统中的每个进程分配资源，直至满足每个进程对资源的最大需求，使每个进程都能顺利完成。如果系统找不到这样一个序列，则称系统处于不安全状态。

系统进入不安全状态并不意味着一定会进入死锁状态，但如果系统处于安全状态，则一定不会进入死锁状态，所以避免死锁可以转换为避免系统进入不安全状态。

最有代表性的避免死锁的算法，是 Dijkstra的**银行家算法**

## 银行家算法

### 数据结构

- 可利用资源向量 Available：这是一个含有 m个元素的数组，其中每一个元素代表一类可利用的资源的数目

  > 初始值使系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而改变。

- 最大需求矩阵 Max：这是一个 n*m的矩阵，它定义了系统中 n个进程各自对 m类资源的最大需求。

  >  如果 Max[i,j]=K，则表示进程 i所需要的 j类资源的最大数目为 K。

- 分配矩阵 Allocation：这是一个 n*m的矩阵，它定义了系统中每类资源已经分配给对应进程的总数。

  > 如果 Allocation[i,j]=K，则表示进程 i已分配 j类资源的数目为 K。

- 需求矩阵 Need：这是一个 n*m的矩阵，它定义了每一个进程还需的各类资源数目。

  > 如果 Need[i,j]=K，则表示进程 i还需要 j类资源的数目为 K。

### 算法

设 Request是进程 P（进程号为 i）的请求向量，Request[j]=K表示进程 P需要 j类资源的数目为 K，当进程发出请求后，系统执行以下步骤进行检查：

1. 如果 Request[j] <= Need[i,j]，转向步骤 2；否则认为出错，因为进程请求的资源已经超过了它之前宣布的最大值。
2. 如果 Request[j] <= Available[i,j]，转向步骤 3；否则认为出错，因为进程请求的资源数已经超过了当前可用的资源数量。
3.  系统将**尝试**资源分配给进程 P，并更新 Max、Available和 Allocation的值： Available[j] = Available[j] - Request[j] Allocation[i,j] = Allocation[i,j] + Request[j] Need[i,j] = Need[i,j] - Request[j] 
4. 系统执行**安全性算法**，检查此次资源分配后系统是否处于安全状态。若安全，则正式将资源分配给进程 P，否则，让进程 P等待。

**安全性算法**

1. 设置两个数组 Work和 Finish，Work的初始值为 Available的值，Work表示系统当前可用的所有资源数目，可以把 Work看作是动态更新的 Available；Finish全部初始化为 false，表示对应进程是否完成，最开始所有进程都未完成。

2.  从进程集合中找到一个满足下述条件的进程 

   - Finish[i] =false；进程未完成
   - Need[i]<=Work；这个不等式表示 Need[i]中的所有元素都小于等于 Work中对应的元素，即表示当前系统可用的资源数目可以满足进程 i顺利执行完成。

    如果找到这样的进程则执行步骤 3，否则执行步骤 4. 

3.  经过步骤 2的检查可以确认进程 j可以顺利执行完成，当进程执行完成后释放资源（这里模拟进程执行完成之后释放资源的操作） Work[j] = Work[j] + Allocation[i,j] Finish[i] = true 转向步骤 2。 

4. 如果所有进程的 Finish都是 false说明进程可以按照某个顺序顺利执行完成，即系统处于安全状态；否则说明有一个或多个进程无法顺利执行完成，即系统处于不安全的状态。

在经过足够的执行次数后，最后剩下的 Finish为 false的进程就是发生了死锁的进程。

# 死锁检测

- 资源分配图

# Linux检测死锁

- 利用 `jps` 命令查看执行的 Java 进程

- 使用 `jstack` 查看具体进程状态

  > "Thread-1":  waiting to lock Monitor@0x00007fea1900f6b8 (Object@0x00000007efa684c8, a java/lang/Object),  which is held by "Thread-0"
  >
  >  "Thread-0":  waiting to lock Monitor@0x00007fea1900ceb0 (Object@0x00000007efa684d8, a java/lang/Object),  which is held by "Thread-1"
