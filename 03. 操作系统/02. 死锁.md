# 死锁是什么

多个进程竞争有限的资源，若一个线程没有可用资源，则进入等待状态。如果占用该资源的线程也再等待其它资源，依次反复形成**循环等待**，称为死锁。

# 死锁四个条件

- 互斥

  一个资源只能被一个进程使用。

- 占有并等待

  一个线程占有一个资源，并且等待另一个资源，而该资源被另一个进程所占用

- 非抢占

  资源不能被抢占，只能在主动释放后才能被分配。

- 循环等待

  一组等待进程，前一个进程等待后一个进程释放资源，后一个期待它后一个释放，依次，最后一个期待第一个释放，形成循环等待。

# 死锁预防

- 破坏“占有并等待”

  - 进程运行前一次分配所有要求的资源
  - 进程提出新的资源申请时，释放它占有的资源

- 破坏“不可抢占”

  - 如果一个进程在申请其他资源时被拒绝，则释放它占有的资源。
  - 如果一个进程申请其他资源被拒绝时，可以抢占该资源。该方法只有在两进程的优先级都不同时有效。

- 破坏“循环等待”

  将系统所有资源进程编号，进程的资源申请都必须按编号顺序提出。

# 死锁避免

**银行家算法**。基本思路：

进程在进入系统前，申明所需要的资源和其最大数目。在分配资源时，进行计算是否有足够资源分配给该进程和进一步计算分配之后是否会让系统处于不安全状态。

# 死锁检测

- 资源分配图

# Linux检测死锁

- 利用 `jps` 命令查看执行的 Java 进程

- 使用 `jstack` 查看具体进程状态

  > "Thread-1":  waiting to lock Monitor@0x00007fea1900f6b8 (Object@0x00000007efa684c8, a java/lang/Object),  which is held by "Thread-0"
  >
  >  "Thread-0":  waiting to lock Monitor@0x00007fea1900ceb0 (Object@0x00000007efa684d8, a java/lang/Object),  which is held by "Thread-1"
