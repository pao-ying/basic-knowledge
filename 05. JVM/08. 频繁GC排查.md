当系统突然运行缓慢，CPU 100%，以及 Full GC 次数过多时，会出现最直观的现象就是**系统运行缓慢，并且有大量报警。**

可能的原因有两种：

- 代码中某个位置读取数据量较大，导致系统内存耗尽，从而导致Full GC次数过多，系统缓慢
- 代码中有比较耗CPU的操作，导致CPU过高，系统运行缓慢

另外有几种情况也会导致某个功能运行缓慢，但是不至于导致系统不可用：

- 代码某个位置有阻塞性的操作，导致该功能调用整体比较耗时，但出现是比较随机的
- 某个线程由于某种原因而进入WAITING状态，此时该功能整体不可用，但是无法复现
- 由于锁使用不当，导致多个线程进入死锁状态，从而导致系统整体比较缓慢

# Full GC 次数过多

相对来说，这种情况最容易出现，有如下两个特征：

- 线上多个线程的CPU都超过了100%，通过jstack命令可以看到这些线程主要是垃圾回收线程
- 通过jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加。

**1.使用 top 命令查看系统 CPU 占用情况**

```javascript
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
    9 root      20   0 2557160 288976  15812 S  98.0 14.1   0:42.60 java
```

可以看到，有一个Java程序此时CPU占用量达到了98.8%，此时我们可以复制该进程id 9，并且使用如下命令查看呢该进程的**各个线程运行情况**：

```
top -Hp 9
```

该进程下的各个线程运行情况

```javascript
  	PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
     10 root      20   0 2557160 289824  15872 R 79.3 14.2   0:41.49 java
     11 root      20   0 2557160 289824  15872 S 13.2 14.2   0:06.78 java
```

**2.使用 jstack 命令查看线程 id 为 10 的线程为什么耗费 CPU 最高**

```javascript
"main" #1 prio=5 os_prio=0 tid=0x00007f8718009800 nid=0xb runnable [0x00007f871fe41000]
   java.lang.Thread.State: RUNNABLE
    at com.aibaobei.chapter2.eg2.UserDemo.main(UserDemo.java:9)
"VM Thread" os_prio=0 tid=0x00007f871806e000 nid=0xa runnable
```

这里的VM Thread一行的最后显示nid=0xa，这里nid的意思就是操作系统线程id的意思。而**VM Thread指的就是垃圾回收的线程**。这里我们基本上可以确定，当前系统缓慢的原因主要是垃圾回收过于频繁，导致GC停顿时间较长。

**3.通过 jstat 查看GC 情况**，使用 **jstat -gcutil 9 1000 10**

```javascript
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT  
  0.00   0.00   0.00  75.07  59.09  59.60   3259    0.919  6517    7.715    8.635  
  0.00   0.00   0.00   0.08  59.09  59.60   3306    0.930  6611    7.822    8.752  
  0.00   0.00   0.00   0.08  59.09  59.60   3351    0.943  6701    7.924    8.867  
  0.00   0.00   0.00   0.08  59.09  59.60   3397    0.955  6793    8.029    8.984 
```

可以看到，这里FGC指的是Full GC数量，这里高达6793，而且还在不断增长。从而进一步证实了是由于内存溢出导致的系统缓慢。

那么这里确认了内存溢出，但是如何查看你是哪些对象导致的内存溢出呢.

**4.这个可以jmap dump出内存日志，然后通过eclipse的mat工具进行查看**，如下是其展示的一个对象树结构：

![](..\img\x16twflam2.jpeg)

经过mat工具分析之后，我们基本上就能确定内存中主要是哪个对象比较消耗内存，然后找到该对象的创建位置，进行处理即可。

这里的主要是PrintStream最多，但是我们也可以看到，其内存消耗量只有12.2%。也就是说，其还不足以导致大量的Full GC，此时我们需要考虑另外一种情况，就是**代码或者第三方依赖的包中有显示的System.gc()调用**。

**5.这种情况我们查看dump内存得到的文件即可判断，因为其会打印GC原因：**

```javascript
[Full GC (System.gc()) [Tenured: 262546K->262546K(349568K), 0.0014879 secs] 262546K->262546K(506816K), [Metaspace: 3109K->3109K(1056768K)], 0.0015151 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
[GC (Allocation Failure) [DefNew: 2795K->0K(157248K), 0.0001504 secs][Tenured: 262546K->402K(349568K), 0.0012949 secs] 265342K->402K(506816K), [Metaspace: 3109K->3109K(1056768K)], 0.0014699 secs] [Times: user=0.00 
```

比如这里第一次GC是由于System.gc()的显示调用导致的，而第二次GC则是JVM主动发起的。

## 原因

总结来说，对于Full GC次数过多，主要有以下两种**原因**：

- 代码中一次获取了大量的对象，导致内存溢出，此时可以通过eclipse的mat工具查看内存中有哪些对象比较多；
- 内存占用不高，但是Full GC次数还是比较多，此时可能是显示的 `System.gc()`调用导致GC次数过多，这可以通过添加 `-XX:+DisableExplicitGC`来禁用JVM对显示GC的响应。

# CPU过高

首先我们通过top命令查看当前CPU消耗过高的进程是哪个，从而得到进程id；然后通过top -Hp来查看该进程中有哪些线程CPU过高，一般超过80%就是比较高的，80%左右是合理情况。这样我们就能得到CPU消耗比较高的线程id。接着通过该线程id的十六进制表示在jstack日志中查看当前线程具体的堆栈信息。

在这里我们就可以区分导致CPU过高的原因具体是Full GC次数过多还是代码中有比较耗时的计算了。如果是Full GC次数过多，那么通过jstack得到的线程信息会是类似于VM Thread之类的线程，而如果是代码中有比较耗时的计算，那么我们得到的就是一个线程的具体堆栈信息。

# 不定期接口耗时现象

对于这种情况，比较典型的例子就是，我们某个接口访问经常需要2~3s才能返回。这是比较麻烦的一种情况，因为一般来说，**其消耗的CPU不多，而且占用的内存也不高**，也就是说，我们通过上述两种方式进行排查是无法解决这种问题的。

而且由于这样的接口耗时比较大的问题是不定时出现的，这就导致了我们在通过jstack命令即使得到了线程访问的堆栈信息，我们也**没法判断具体哪个线程**是正在执行比较耗时操作的线程。

**定位思路**

首先找到该接口，通过压测工具不断加大访问力度，如果说该接口中有某个位置是比较耗时的，由于我们的访问的频率非常高，那么大多数的线程最终都将阻塞于该阻塞点，这样通过多个线程具有相同的堆栈日志，我们基本上就可以定位到该接口中比较耗时的代码的位置。

# 某个线程进入 waiting

# 死锁

jstack

![](..\img\kafw9dl3pc.jpeg)

可以看到，在jstack日志的底部，其直接帮我们分析了日志中存在哪些死锁，以及每个死锁的线程堆栈信息。这里我们有两个用户线程分别在等待对方释放锁，而被阻塞的位置都是在ConnectTask的第5行，此时我们就可以直接定位到该位置，并且进行代码分析，从而找到产生死锁的原因。

# 小结

本文主要讲解了线上可能出现的五种导致系统缓慢的情况，详细分析了每种情况产生时的现象，已经根据现象我们可以通过哪些方式定位得到是这种原因导致的系统缓慢。简要的说，我们进行线上日志分析时，主要可以分为如下步骤：

- 通过 `top`命令查看CPU情况，如果CPU比较高，则通过 `top-Hp<pid>`命令查看当前进程的各个线程运行情况，找出CPU过高的线程之后，将其线程id转换为十六进制的表现形式，然后在jstack日志中查看该线程主要在进行的工作。这里又分为两种情况
- 如果是正常的用户线程，则通过该线程的堆栈信息查看其具体是在哪处用户代码处运行比较消耗CPU；
- 如果该线程是 `VMThread`，则通过 `jstat-gcutil<pid><period><times>`命令监控当前系统的GC状况，然后通过 `jmapdump:format=b,file=<filepath><pid>`导出系统当前的内存数据。导出之后将内存情况放到eclipse的mat工具中进行分析即可得出内存中主要是什么对象比较消耗内存，进而可以处理相关代码；
- 如果通过 `top` 命令看到CPU并不高，并且系统内存占用率也比较低。此时就可以考虑是否是由于另外三种情况导致的问题。具体的可以根据具体情况分析：
- 如果是接口调用比较耗时，并且是不定时出现，则可以通过压测的方式加大阻塞点出现的频率，从而通过 `jstack`查看堆栈信息，找到阻塞点；
- 如果是某个功能突然出现停滞的状况，这种情况也无法复现，此时可以通过多次导出 `jstack`日志的方式对比哪些用户线程是一直都处于等待状态，这些线程就是可能存在问题的线程；
- 如果通过 `jstack`可以查看到死锁状态，则可以检查产生死锁的两个线程的具体阻塞点，从而处理相应的问题。

https://cloud.tencent.com/developer/article/1536011