# 组成

JVM内存结构=类加载器+执行引擎+运行时数据区域.

![image-20210905150636105](..\img\image-20210905150636105.png)

## 程序计数器

- 当前线程执行的行号指示器,通过改变它能够实现代码的**流程控制**, 如循环, 选择等.
- 多线程情况下, 用来记录当前运行的行号, 当线程切换回来后能够继续执行

## 虚拟机栈

Java虚拟机栈是每个内存所需要的内存空间，由一个个栈帧组成, 每个栈帧包括: 局部变量表, 操作数栈, 动态链接, 方法出口信息.

方法调用时就入栈, 方法执行完成后就出栈.

- 局部变量表用于存放方法参数和方法内局部变量

- 操作数栈中保存着计算的具体的数值

- 动态链接

  用于在运行期间将符号引用转换为直接引用

  > 部分符号引用在类加载阶段就转为了直接引用, 这种转换就是静态链接
  >
  > 在运行期间转为直接引用, 这种转换就是动态链接

### 参数

> -Xss

### 异常

> StackOverFlowError
>
> OutOfMemoryError

## 本地方法栈

虚拟机栈为虚拟机执行Java方法服务, 本地方法栈为虚拟机执行Native方法服务.

## 堆

堆的唯一目的就是用来存放对象实例, 并且几乎所有的对象实例**以及数组**都在堆中进行分配内存.

Java堆是**垃圾回收**的主要区域, 也称作**GC堆**

### 参数

> -Xms

### 异常

> OutOfMemoryError

## 方法区

用于存储已被虚拟机加载的类信息, 常量, 静态变量, JIT编译后的代码等数据.

方法区逻辑上属于堆的一部分, 对方法区回收主要目标是对常量池的回收和对类的卸载

### 永久代

永久代是jdk1.8之前**方法区的实现方式**. 

### 元空间

元空间是jdk1.8之后的方法区实现方式. 与永久代的区别: **元空间不在虚拟机中, 而是在直接内存中**.

>  替换的原因:
>
> 永久代的大小受限于JVM的大小, 而元空间的大小取决于直接内存的大小, 溢出的概率更小.

## 运行时常量池

## 说明

.class中的常量池用于存放编译期生成的各种字面量和符号引用，这部分内容在**类加载**过后进入运行时常量池。

## StringTable

### 说明

用来存储运行时常量池中的Java字符串对象，使用synchronized保证线程安全

### 延迟加载

```java
String s1 = "a";
String s2 = "b";
String s3 = "c";
```

当类还没有加载时,即常量池中的信息还未加载到运行时常量池时, a, b, c还只是常量池中的符号, 还没有变为 java 字符串对象.

当类加载后, **运行到需要加载字符串的代码时**, 再从 StringTable 中查找是否含有该字符串对象, 如果没有则向 String Table中添加该字符串对象.

### 字符串拼接

```java
String s4 = s1 + s2;	
```

使用反编译.class代码后可以发现, 该段代码实际执行的是

```java
new StringBuilder().append("a").append("b").toString()
```

而`toString()`方法是`return new String("ab")`,

所以字符串拼接是返回一个**新的字符串对象**.

```java
s3 != s4
```

由于 s3 是存在于 **StringTable** 中的

而 s4 是存在于 **堆** 中的

### 编译器优化

```java
String s5 = "a" + "b";
s3 == s5
```

使用反编译.class代码后可以发现, s5 是直接调用StringTable的 `"ab"` 字符串对象的.

这是因为javac 在编译期间的**优化**, 在编译期间已经能确定为"ab"了.

### intern

- **1.8**  将堆中的字符串对象尝试放入串池, 如果有, 并不会放入, 直接返回该对象;  没有则放入串池, 同时将池中的对象返回

  ```java
  String s = new String("a") + new String("b");
  String s1 = s.intern();
  s1 == "ab"; // true
  s == "ab" // true
  ```

  当编译时, 将 "a" 和 "b" 字符串对象放入 StringTable, 运行时将 "ab"字符串对象 放入堆中.

  `s1 = s.intern()`将堆中的"ab"字符串对象的**引用**放入StringTable中, 且返回该引用.

  所以同时 **s=="ab"** 也是真的

  ```java
  String x = "ab";
  String s = new String("a") + new String("b");
  String s1 = s.intern();
  s1 == x; // true
  s == x; // false
  ```

- 1.6 是将堆中的字符串复制一份放入StringTable中

  ```java
  String s = new String("a") + new String("b");
  String s1 = s.intern();
  s1 == "ab"; // true
  s == "ab" // false
  ```

### 特性

1. 常量池中的字符串仅是符号, 第一次用到时才会变成字符串对象
2. 串池机制可以避免重复创建字符串
3. 字符串**变量**拼接原理是StringBuilder
4. 字符串**常量**拼接的原理是**编译器优化**
5. 使用**intern**方法,将串池中还没有的字符串对象放入串池
   - 1.8 将堆中的字符串对象尝试放入串池, 如果有, 并不会放入, 没有则放入串池, 同时将池中的对象返回
   - 1.6 是复制一份

### 位置

1.6 运行时常量池是在 **永久代**中, 1.8是在**堆**. 

换位置的原因是, 永久代只有在**full gc ** 的情况下才会进行回收, 而我们需要大量使用到常量, 如果更新不及时, 会造成内存的浪费. 

> 程序报 overHeadLimit 而不是 OOM , 这是因为JVM花了９８％的时间进行ｇｃ，但是只回收了％２的内存，JVM就会报这个错误

## 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。

### 文件读写过程

在**CPU**中，Java是无法从**系统内存**中直接读取到文件信息的，所以需要从**用户态(Java)**转到**内核态(system)**， 同时在**内存**中，磁盘文件信息需要先将数据复制到**系统内存**中的**系统缓存区**中，再复制到**Java堆内存**中的**Java缓存区byte[]**中，Java才能将其读取。

### NIO读写过程

NIO使用的是**byteBuffer(调用DirectBuffer)**，能够访问系统物理内存. 其中CPU从用户态转到内核态不变，变化的是，在内存中，系统内存和Java堆内存共享一块**直接内存**，系统和JAVA都能够对其调用，这样就避免了繁琐的复制。

# Java对象定位方式

通过栈上的**reference**数据操作堆上的具体对象. 访问方式:

- 通过句柄. Java堆中分配一块区域作为句柄池. reference存储对象句柄位置, 句柄中再包含具体的地址信息. 好处是对象改变时不需要改变reference, 只需要改变句柄内部的指针.
- 直接指针. reference中存储的就是对象的物理地址. 好处就是访问对象速度快. 

hotspot默认使用直接指针

# 堆和栈的区别

- 物理地址

  堆的物理地址**分配对象**是不连续的. 而栈使用的是数据结构中的栈, 物理分配是连续的.

- 存放的内容

  堆中存放的是实例和**数组**

  栈中存放的是: 局部变量, 操作数栈, 返回结果

- 程序可见度

  堆是进程级别的, 而栈是线程级别的

