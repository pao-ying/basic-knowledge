# 标记-清除算法

标记出所有**不需要回收**的对象, 在标记完成后统一**回收所有没有标记**的对象.

## 产生的问题

1. 效率问题, 效率较低
2. 空间问题, 产生大量的空间碎片

# 复制-清除算法

将内存分为大小相同的两块, 每次只使用其中一块, 当这一块的内存使用完后, 将存活的对象复制到另一块上去, 然后再把使用的空间清理掉.

## 产生的问题

可用内存变为原来一半

# 标记整理算法

标记过程与标记-清除算法一样, 但是后续步骤不是直接对可回收对象回收, 而是将所有存活对象向一端一段移动, 清理掉边界以外的内存

# 分代收集算法

一般将堆分为新生代和老年代

- 新生代使用: 复制-清除算法
- 老年代使用: 标记-清除或者标记-整理算法

## 新生代

由于minor gc中会有大量的对象死去, 只有少量存活, 所以选用复制算法, **只需要复制少量的对象**, 就可以完成收集

## 老年代

由于老年代中对象存活率较高, 没有额外空间进行复制, 就必须使用**标记-清理**或者**标记-整理**算法进行回收.

## 跨代引用

由于对象之间如果存在跨代引用, 则在 minor gc 中, 不仅要遍历新生代对象, 还要额外遍历老年代对象, 会给内存回收带来性能负担.

又由于存在互相引用的两个对象, 倾向于同时生存或者同时消亡的. 比如说新生代对象引用了老年代对象, 由于老年代对象难以消亡, 则在minor gc中新生代对象也会存活下来, 则随着年龄增长, 新生代对象也会变成老年代对象.

其中跨代引用相对于同代引用来说少很多, 没必要因此遍历老年代.

所以解决办法就是 在新生代中**建立一个数据结构 Remembered Set**, 这个数据结构将老年代分为若干个小块, 标识出**老年代哪一块中存在跨代引用**. 此后当发生minor gc时, 只有包含了跨代引用的对象才会进行遍历.

