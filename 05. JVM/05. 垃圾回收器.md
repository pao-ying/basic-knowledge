# 相关概念

- 并行收集

  多条垃圾回收线程同时进行工作, 此时用户线程处于等待状态

- 并发收集

  多条垃圾回收线程与用户线程同时进行, 不一定是并行的, 也有可能是交替的.

- 吞吐量优先

  CPU用于运行用于代码和CPU总消耗时间比值越大越好, 代表用于垃圾回收的时间就更少.

- 响应优先

  由于GC会停顿用户线程, 所以响应优先就是尽可能保证GC停顿时间短

# 垃圾回收器

## Serial收集器

使用一条**垃圾回收线程**进行垃圾回收, 在进行垃圾回收时, 必须暂停其他所有用户线程, 即STW, 直到收集结束.

### 特点

并行, 适用于新生代, 采用复制算法, 目标是响应速度优先

# ParNew收集器

Serial的多线程版本, 其余与serial一致

## 特点

并行, 适用于新生代, 采用复制算法, 目标是响应速度优先

# Parallel Scavenge收集器

与ParNew相似, 最大的区别就是含有**GC自适应调节策略**

> GC自适应调节策略:
>
> 通过设置**-XX:+UseAdptiveSizePolicy**参数, 自动设置新生代的大小, Eden和Survior的比例, 晋升老年代的年龄等, 已到达更高的吞吐量.

也可以单独设置, parallel Scanvenge使用两个参数用于**精确控制吞吐量**

- 最大垃圾收集停顿时间

  ```
  -XX: MaxGCPauseMillis
  ```

- 吞吐量大小

  ```
  -XX: GCTimeRatio
  ```

## 特点

并行, 适用于新生代, 采用复制算法, 目标是吞吐量优先

## 较ParNew优点

1. 精确控制吞吐量
2. 可自适应调整策略, 使用 `UseAdaptiveSizePolicy`, 可自动调节新生代大小, Eden与Suvivor比例等

# Serial Old收集器

Serial收集器的老年代版本

## 特点

串行, 适用于老年代, 采用标记-整理算法, 目标是响应速度优先

# Paraller Old收集器

ParNew 的老年代版本

## 特点

并行, 适用于老年代, 采用标记-整理算法, 目标是吞吐量优先

# CMS

并发标记清除, 目的是获取最短的应用停顿时间, 即响应时间优先.

CMS垃圾回收算法基于**标记-清除**算法, 分为四个步骤

- 初始标记

  stw, 记录直接与GC ROOT相连的对象, 速度较快

- 并发标记

  用户线程和GC同时运行, 记录可达对象

- 重新标记

  stw, 修正并发标记阶段由于用户程序继续运行导致标记产生变动的那部分标记记录, 时间上高于初始标记, 但是远小于并发标记

- 并发清除

  用户线程和GC同时运行, 开始对未标记区域进行清除.

## 优点

并发收集, 低停顿, 响应时间优先

## 缺点

- 采用并发清除算法, 会产生大量的空间碎片
- 产生浮动垃圾, 由于并发清除时, 用户线程还在运行, 所以这部分产生的垃圾无法清除
- 对处理器资源敏感. 在并发阶段, 占用了一部分线程执行垃圾回收, 降低总吞吐量.

## 特点

1. 只回收老年代和永久代, 不会受年轻代
2. cms回收时不是等待老年代用尽, 而是当达到92%, 就会执行. 主要是为了预留一部分空间给用户线程运行

并发, 适用于老年代, 采用标记-清除算法, 目标时响应时间优先

# G1收集器

追求吞吐量和响应速度的最佳平衡

之前的垃圾收集器的目标范围都是某一代, 比如新生代就是minor GC, 老年代就是 major GC, 整个堆就是 full gc. 而G1不再面向某一个代进行回收, 而是**那块内存垃圾数量多, 且回收收益大**, 这就是G1的**Mixed GC**模式.

G1 将堆内存分为相同大小的**Region**, 即分区. 有四种不同类型的分区: Eden, Suvivor, Old, Humongous(大对象). G1认为只要是大小超过了一个Region的一般即为大对象

**G1对各个Region回收所获得的空间大小和回收所需时间的经验值**进行排序, 得到一个优先队列, 根据**用户设置的最大停顿时间`MaxGcPauseMillis`**优先处理**回收价值最大**的Region

G1中也会存在有跨区引用的问题, G1也是使用**Remmered Set**避免扫描整个堆. 即每个Region都有一个Rset, 这个Rset中记录了哪些Region引用了该Region, 那么扫描时, 只需要去对应Region查找即可.

回收过程:

- 初始标记

  stw, 记录与GC ROOT直接相连的对象, 速度较快

- 并发标记

  回收与用户线程并发执行, 从GC ROOT开始对队中对象进行可达性分析, 标记可达对象, 这阶段耗时较长

- 最终标记

  对用户线程进行短暂的暂停, 用于处理并发阶段由于用户线程运行引发的标记变动.

- 筛选回收

  **对各个Region的回收价值进行排序**, 根据用户期望的停顿时间**指定回收计划**. 将决定回收的一部分region复制到空的region中, 再清理掉整个旧的region的全部空间.

  stw, 并且由多条手机线程完成

## 特点

可以由用户指定期望的垃圾收集停顿时间

并发, 适用于老年代和新生代, 采用标记-整理和复制算法, 目标是响应速度优先

# 三色标记算法

G1 和 CMS 并发标记阶段采用的是**三色标记算法**。

## 三色

![img](..\img\webpff)

## 过程

在初始标记阶段遍历所有 GC ROOT 直接可达的对象，并压入**标记栈**。并发标记过程中会逐一从**标记栈**中弹出对象，然后标记可达的对象并压入，弹出自身和成员变量均已标记的对象。

## 漏标

当并发标记阶段由于用户线程也在运行，所以会发生引用变动，造成黑色指向了白色，如果不对黑色进行重新扫描，则会出现漏标问题。

![img](..\img\webpcc)

### 发生条件

- 黑色对象引用白色对象
- 灰色对象指向白色对象的引用消失

### 解决方法

- 跟踪黑色对象指向白色对象的引用增加

  **increment update**写屏障：**增量更新**，关注引用的删除，将黑色对象重新标记为灰色对象。**CMS采用此方法**

- 记录灰指向白消失

  **STAB **写屏障：关注引用的删除，当灰色指向白色的引用消失时，将该引用推到标记栈中，保证白色能够被扫到。**G1采用此方法**。

### 为什么G1采用STAB

因为增量更新把黑色标记为灰色，则之前扫描过的还需要再扫描，效率低下。

其次 STAB 可以和 Remembered Set 配合使用。其中记录了对象的引用，则发生灰色对白色的引用消失时，可以把白色对象推向堆栈，使用 Rset 就不需要遍历整个堆查找指向白色的引用，效率比较高。

# JDK1.8垃圾回收器

Parallel Scavenge + Parallel Old
