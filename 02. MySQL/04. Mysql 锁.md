# 并发控制

如果没有做好并发控制，就会导致**脏读、幻读和不可重复读**等问题。

实现并发控制的主要手段就是**乐观并发控制**和**悲观并发控制**。

![img](..\img\2090222-20200831212351434-626106497.png)

# 行级锁

### 说明

**行锁在 InnoDB 是基于索引实现的**，所以如果某个加锁操作没有使用索引，则该锁就会退化成表锁。

## 类型

共享锁、排他锁、意向共享锁、意向排他锁

## 行锁方式

- 记录锁 Record Lock

- 间隙锁 Gap Lock

- 临键锁 Next-Key Lock

  > 当 InnoDB 扫描索引记录时，会对索引记录加上行锁 Record Lock，再对索引记录两边的间隙加上间隙锁 Gap Lock。

### 记录锁 Record Lock

记录锁就是为某行记录加锁，如：

```sql
select * from table where id = 1 for update;
update set age = 50 where id = 1;
```

其中 `id = 1` 的记录行会被锁住。

**注意**：

id 列必须是**唯一索引或者主键**，否则上述锁就会变成**临键锁**。

同时查询也必须为**精准匹配(=)**，不能是 >, <, like 等，否则也会变成**临键锁**。

READ COMMITED 下，采用记录锁。

### 间隙锁 Gap Lock

间隙锁的作用仅仅是防止幻行。

间隙锁**基于非唯一索引**，它可以锁住两个索引之间的间隙、第一个索引之前或者最后一个索引之后的间隙。间隙中的所有记录都会被锁住，其它数据往间隙中插入或删除都会被阻塞。

如:

```sql
select * from table where id between 1 and 5 for update;
```

即将所有 (1, 5) 区间内的记录行都会被锁住，所有 id 为 2, 3, 4 的数据行插入都会被阻塞，但是 1 和 5 数据行不会被锁住。

### 临键锁 next-key

临键锁是一种特殊的间隙锁，同样也是基于非唯一索引。也可以说是 记录锁+间隙锁。

**每个数据行上的非唯一索引上都会有一把临键锁**。当某个事务持有该记录行的临键锁时，会锁住一段**左开右闭**的数据。

> 在当前读的情况下, 解决 InnoDB 幻读问题

如：`age` 是普通索引

| id   | age  | name   |
| ---- | ---- | ------ |
| 1    | 10   | Lee    |
| 3    | 24   | Soraka |
| 5    | 32   | Zed    |
| 7    | 45   | Talon  |

则 `age` 列潜在的临键锁为

(-∞,10], (10, 24], (24, 32], (32, 45], (45, +∞]

```sql
update table set name = NewName where age = 24;
select * from table where age = 24 for update;
```

则 （24, 32] 和 (32, 45] 都会被锁住。

**在对记录行使用 update, for update, lock in share mode 操作时， InnoDB 会获取记录行的临键锁，并同时获取该记录的下一区间的间隙锁**。

### 总结

- InnoDB 行锁实现依赖于索引，如果没有索引，则会退化为表锁。
- 记录锁存在于包括主键索引在内的唯一索引之中，锁定单条索引记录。
- 间隙锁存在于非唯一索引中，是一个开区间，锁定两个索引之间的间隙、第一个索引之前的间隙或者最后一个索引的间隙。
- 临键锁存在于非唯一索引中，每个非唯一索引都有一个临键锁，是一个左开右闭的区间，锁住前一个索引到当前索引的间隙和当前索引记录。

https://www.cnblogs.com/jelly12345/p/14491009.html

# 悲观锁

依靠数据库提供的锁机制。

## 共享锁

读锁，S锁。共享锁就是多个事务对于同一个数据可以共享一把锁，**只读不能修改**

## 排他锁

写锁，X锁。排他锁就是不能与其他所并存，一个事务获得了排他锁，则该事务不能再获得其他锁。

## 具体实现

- 对数据修改之前加上**排他锁**
- 加锁失败说明正在使用；枷锁成功说明可以修改，**事务完成后就会解锁**

使用**for update**的方式进行加锁

# 乐观锁

乐观锁不会使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。

使用 CAS 和版本号控制来实现.

## CAS

CAS即比较与交换，包含三种操作数：**内存位置V、旧值A和新值B**。

如果**内存位置的值与旧值相匹配**，则将该位置值更新为新值。否则不做任何处理。

> Java中，sun.misc.Unsafe类提供了硬件级别的原子操作实现CAS，java.util.concurrent包下大量的类都使用了这个Unsafe.java类实现CAS操作。

示例：

```sql
// 查出商品的quantity=3
select quantity from items where id = 1;
// 修改为2，同时条件上叫上quantity
update items set quantity = 2 where id = 1 and quantity = 3;
```

再更新改制之前先查看对应值，然后在更新时的条件上加上该值。

## ABA问题

如果一个线程修改内存位置的V值，假设原来是A，先修改为B，在修改成A。则当前线程CAS操作无法分辨当前V值是否修改过。

这就会导致当多个线程取到去一个值时，如线程1和线程2取到quantity=3，这时线程一将quantity=2后又让quantity=3。线程2取到的仍是quantity=3，那么线程2同样可以进行CAS操作。

### 解决方法

**添加一个可以顺序增加的version字段**

乐观锁在每次修改数据时，都会加上一个版本号，一旦版本号和数据的版本号一致就可以执行修改，并且对版本号执行+1操作；不一致就执行失败。

那么对于上面的例子，初始化版本号为0，则线程1执行完两次更新操作后版本号为2，那么对于线程2来说，版本号不匹配，就不会执行CAS操作。

## CAS典型应用

java.util.concurrent.atomic包下的大多数使用的是CAS操作，如AtomicInteger，AtomicBoolean，AtomicLong。

## 支持计数功能

不使用synchoronized，而是使用AtomicInteger

```
public static AtomicInteger count = new AtomicInteger(0);
public static void increase() {
	c
}
```

