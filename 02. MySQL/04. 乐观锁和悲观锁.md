# 并发控制

如果没有做好并发控制，就会导致**脏读、幻读和不可重复读**等问题。

实现并发控制的主要手段就是**乐观并发控制**和**悲观并发控制**。

# 悲观锁

依靠数据库提供的锁机制。

## 共享锁

读锁，S锁。共享锁就是多个事务对于同一个数据可以共享一把锁，**只读不能修改**

## 排他锁

写锁，X锁。排他锁就是不能与其他所并存，一个事务获得了排他锁，则该事务不能再获得其他锁。

## 具体实现

- 对数据修改之前加上**排他锁**
- 加锁失败说明正在使用；枷锁成功说明可以修改，**事务完成后就会解锁**

使用**for update**的方式进行加锁

# 乐观锁

乐观锁不会使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。

## CAS

CAS即比较与交换，包含三种操作数：**内存位置V、旧值A和新值B**。

如果**内存位置的值与旧值相匹配**，则将该位置值更新为新值。否则不做任何处理。

> Java中，sun.misc.Unsafe类提供了硬件级别的原子操作实现CAS，java.util.concurrent包下大量的类都使用了这个Unsafe.java类实现CAS操作。

示例：

```sql
// 查出商品的quantity=3
select quantity from items where id = 1;
// 修改为2，同时条件上叫上quantity
update items set quantity = 2 where id = 1 and quantity = 3;
```

再更新改制之前先查看对应值，然后在更新时的条件上加上该值。

## ABA问题

如果一个线程修改内存位置的V值，假设原来是A，先修改为B，在修改成A。则当前线程CAS操作无法分辨当前V值是否修改过。

这就会导致当多个线程取到去一个值时，如线程1和线程2取到quantity=3，这时线程一将quantity=2后又让quantity=3。线程2取到的仍是quantity=3，那么线程2同样可以进行CAS操作。

### 解决方法

**添加一个可以顺序增加的version字段**

乐观锁在每次修改数据时，都会加上一个版本号，一旦版本号和数据的版本号一致就可以执行修改，并且对版本号执行+1操作；不一致就执行失败。

那么对于上面的例子，初始化版本号为0，则线程1执行完两次更新操作后版本号为2，那么对于线程2来说，版本号不匹配，就不会执行CAS操作。

## CAS典型应用

java.util.concurrent.atomic包下的大多数使用的是CAS操作，如AtomicInteger，AtomicBoolean，AtomicLong。

## 支持计数功能

不使用synchoronized，而是使用AtomicInteger

```
public static AtomicInteger count = new AtomicInteger(0);
public static void increase() {
	c
}
```

