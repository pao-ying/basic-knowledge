# MVCC

即多版本并发控制，为每个修改保存一个版本，避免了加锁操作，降低了开销。

避免了幻读现象。

## 当前读

select * * lock in share mode

select ** for update

当前读就是读取的是记录的最新版本，读取时会给数据加锁，保证其他记录不能修改当前记录。

>  InnoDB通过MVCC避免了幻读问题，当时MVCC机制无法避免当前读情况下出现的幻读现象。因为每次读取的都是最新的数据，如果在两次查询之间有其他事务插入数据，就会产生幻读。

## 快照读

select * from

快照读就是不加锁的非阻塞读，不涉及其它锁之间的冲突。

**快照读的实现就是基于MVCC。**

## 实现原理

主要依赖三个隐式字段（版本链）、undo日志、Read View来实现。

### 隐式字段（版本链）

- DB_TRX_ID

  当前事务ID

- DB_ROLL_PTR

  回滚指针，指向这条记录的上一个版本

- DB_ROW_ID

  隐含的自增ID

使用事务更新记录时，就会生成版本链，执行过程：

1. 使用**排他锁**锁住该行
2. 将改行原本的值拷贝到 undo log，作为旧版本回滚
3. 修改当前行的值，生成一个新的版本，更新事务ID，使用回滚指针指向旧的版本记录。

### undo log

- insert undo log 

  事务在insert新记录时产生的，事务回滚时需要，**事务提交后丢弃**。

- update undo log

  事务在update或者delete时产生，不仅在回滚的时候需要，还在快照读的时候需要。所以只有在快照读和事务回滚都不涉及该日志时才会由**purge**线程删除。

> MVCC机制中的更新或者删除都只是设置老记录的**deleted_bit**，而不是真正将过失的记录删除。
>
> 所以InnoDB有专门的**purge**线程来清除**deleted_bit**为true的记录。

### ReadView

读视图，ReadView就是事务进行快照读(select * from)操作时生产的读视角。

ReadView会在事务进行快照读时，形成当前**事务系统**的快照，并且记录和维护系统当前活跃事务（未提交事务）的ID，用来判断当前事务是否提交（是否可见）。

不同隔离级别创建read view时机：

- 读已提交：每次select都创建新的，保证能读到其他事务已提交的修改
- 可重复读：**一个事务范围内**，第一次select更新readview。保证事务范围内，每次读到的内容相同。

## 总结

InnoDB的MVCC是通过Read View和版本链实现的，版本链保存有历史版本信息，通过readview判断当前事务是否可见，如果不可见，则从版本链中查找上一个版本，继续执行判断，直到找到可见的版本。

