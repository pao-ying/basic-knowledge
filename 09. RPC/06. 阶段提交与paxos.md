# 分布式事务

分布式事务主要是为了保证在**整个调用链**中，所有服务的数据处理要么都成功，要么都失败，也就是所有服务的原子性问题。

> 发起订单处理会增加积分，调用积分和订单两个服务，积分处理完后调用订单服务中，如果出现网络波动，没有成功调用订单服务，这样就会出现问题。

**两阶段提交**是一种保证分布式系统数据一致性的协议，现在很多数据库都是采用的两阶段提交协议来完成 **分布式事务** 的处理。

# 两阶段提交

两阶段提交主要有两个角色，分别是**协调者**和**参与者**。

## 第一阶段

当要执行一个分布式事务的时候，首先向**协调者**发起事务请求，然后协调者会给所有**参与者**发送 `prepare` 请求（其中包括事务内容）通知参与者执行事务。参与者收到 `prepare` 请求后，他们会开始执行事务（但不提交），并将 `Undo` 和 `Redo` 信息记入事务日志中，之后参与者就向协调者反馈是否准备好了。

## 第二阶段

第二阶段主要是协调者根据参与者反馈的情况来决定接下来是否可以进行事务的提交操作，即**提交事务或者回滚事务。**

如果所有参与者都返回了准备好了的消息，这个时候就进行事务的提交，协调者此时会给所有的参与者发送 **`Commit` 请求** 。参与者收到 `Commit` 请求的时候会执行前面执行的事务的 **提交操作** ，提交完毕之后将给协调者发送提交成功的响应。

如果在第一阶段并不是所有参与者都返回了准备好了的消息，那么此时协调者将会给所有参与者发送 **回滚事务的 `rollback` 请求**，参与者收到之后将会 **回滚它在第一阶段所做的事务处理** ，然后再将处理情况返回给协调者。

最终协调者收到响应后便给事务发起者返回处理失败的结果。

## 问题

- **单点故障**，如果协调者挂了那么整个系统都处于不可用的状态了。
- **阻塞问题**，即当协调者发送 `prepare` 请求，参与者收到之后如果能处理那么它将会进行事务的处理但并不提交，这个时候会一直占用着资源不释放，如果此时协调者挂了，那么这些资源都不会再释放了，这会极大影响性能。
- **数据不一致问题**，，比如当第二阶段，协调者只发送了一部分的 `commit` 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。

# 三阶段提交

- **CanCommit阶段**：协调者向所有参与者发送 `CanCommit` 请求，参与者收到请求后会根据自身情况查看是否能执行事务，如果可以则返回 YES 响应并进入预备状态，否则返回 NO 。
- **PreCommit阶段**：
  - 如果上面参与者返回的都是 **YES**，那么协调者将向所有参与者发送 `PreCommit` 预提交请求，**参与者收到预提交请求后，会进行事务的执行操作，并将 `Undo` 和 `Redo` 信息写入事务日志中** ，
  - 如果在第一阶段协调者收到了 **任何一个 NO** 的信息，或者 **在一定时间内** 并没有收到全部的参与者的响应，那么就会中断事务，它会向所有参与者发送中断请求（abort），参与者收到中断请求之后会立即中断事务，或者在一定时间内没有收到协调者的请求，它也会中断事务。

- **DoCommit阶段**：

  - 这个阶段其实和 `2PC` 的第二阶段差不多，如果协调者收到了所有参与者在 `PreCommit` 阶段的 YES 响应，那么协调者将会给所有参与者发送 `DoCommit` 请求，**参与者收到 `DoCommit` 请求后则会进行事务的提交工作** 。

  - 若协调者在 `PreCommit` 阶段 **收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应** ，那么就会进行中断请求的发送，参与者收到中断请求后则会 **通过上面记录的回滚日志** 来进行事务的回滚操作

`3PC` 通过一系列的超时机制很好的缓解了阻塞问题，但是最重要的一致性并没有得到根本的解决，比如在 `PreCommit` 阶段，当一个参与者收到了请求之后其他参与者和协调者挂了，这个时候收到消息的参与者都会进行事务提交，这就会出现数据不一致性问题。

# Paxos算法

`Paxos` 算法是基于**消息传递且具有高度容错特性的一致性算法**，是解决分布式一致性问题最有效的算法之一，**其核心思路就是在分布式系统中如何就某个值（决议）达成一致** 。

在 `Paxos` 中主要有三个角色，分别为 `Proposer提案者`、`Acceptor表决者`、`Learner学习者`，主要分为两阶段，分别为 `prepare` 和 `accept`阶段。

## prepare

- `proposer 提案者` 负责提出 `proposer`，每次都会生成一个**全局性的、递增的提案编号**，即在整个集群中唯一的编号，**在第一阶段只是将提案编号发送给所有表决者**
- `accptor表决者` 在 `accept`某提案后，将编号记录在本地，这样每个表决者在本地都会保存一个**编号最大的提案**，编号为 **MaxN**。每个表决者只会 `accept` 编号大于本地 `MaxN`的提案。同时表决者将**接受的最大编号提案**作为相应反馈给 提案者。

## accept

1. 当提案者提出的提案被**超过半数**的表决者同意后，提案者会给所有的表决者发送**真正的提案。**
2. 表决者收到提案后，比较该提案的编号与**已经接受的最大提案编号**，如果**大于等于**，那么就`accept` 该提案，只执行不提交，随后将情况返回给提案者，不满足则不回应或者返回NO。
3. 如果提案者收到半数以上的 `accept`，那么就会向**所有**表决者发送**提案的提交请求**。区别是，对于未批准的表决者，提案者也会发送该提案内容和编号并强制执行和提交；对于已批准的表决者，提案者发送提案编号，要求表决者提交。
4. 如果提案者没有收到半数以上的 `accept`，那么就递增该提案编号，重新进入 `prepare`阶段。