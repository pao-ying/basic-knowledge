# 持久化机制

- 快照持久化 RDB
- 之追加文件 AOF

# 快照持久化RDB

RDB 持久化机制，是对 Redis 中的数据执行**周期性的持久化**。

redis将数据快照存放在磁盘上的二进制文件中 `dump.rdb`

可以在 `redis.conf`中配置**多久后至少多少个key发生变化时，创建快照**。

```
save 900 1
在900秒后，如果至少有1个key发生了改变，则会创建快照
```

## 对过期 key 处理

过期key对RDB没有任何影响

- 从内存数据库持久化数据到RDB文件
  - 持久化key之前，会检查是否过期，过期的key不进入RDB文件
- 从RDB文件恢复数据到内存数据库
  - 数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）

## 原理

Redis 使用 **写时复制技术 COW(copy on write)**来实现快照持久化，保证数据一致性。

Redis 在持久化时会 fork 一个 **bgsave** 子进程，快照持久化交由该子进程，父进程继续处理客户端请求。

当主线程执行写指令修改数据时，这个数据就会复制一份副本，bgsave 子进程读取这个副本写到 RDB 文件中。

这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响

## 优点

他会生成多个数据文件，每个数据文件分别都代表了**某一时刻Redis**里面的数据，这种方式，有没有觉得很适合做**冷备**，完整的数据运维设置定时任务，定时同步到远端的服务器，比如阿里的云服务，这样**一旦线上挂了，你想恢复多少分钟之前的数据，就去远端拷贝一份之前的数据就好了**。

**RDB**对**Redis**的**性能影响非常小**，是因为在同步数据的时候他只是**fork**了一个子进程去做持久化的，而且他在数据恢复的时候速度比**AOF**来的快。

## 缺点

**RDB**都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。**AOF**则最多丢一秒的数据，**数据完整性**上高下立判。

还有就是**RDB**在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒，你公司在做秒杀的时候他刚好在这个时候**fork**了一个子进程去生成一个大快照，哦豁，出大问题。

# AOF

即**只追加文件机制**

开启AOF持久化之后，**每执行一条更改redis数据中的命令，都会写入 `server.aof_buf`内存缓存中**

然后再根据 **appendsync** 配置来决定何时同步到硬盘的 AOF 文件中。

AOF持久化技术有三种配置

- appendsync always

  每次有数据修改都写入aof

- appendsync everysec

  每秒钟同步一次

- appendsync no

  让操作系统决定

## 对过期 key 处理

过期key对AOF没有任何影响

- 从内存数据库持久化数据到AOF文件：
  - 当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）
  - 当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）
- AOF重写
  - 重写时，会先判断key是否过期，已过期的key不会重写到aof文件 

## 优点

**RDB**五分钟一次生成快照，但是**AOF**是一秒一次去通过一个后台的线程`fsync`操作，那最多丢这一秒的数据。

**AOF**在对日志文件进行操作的时候是以`append-only`的方式去写的，他**只是追加的方式写数据**，自然就少了很多**磁盘寻址的开销**了，写入性能惊人，文件也不容易破损。

## 缺点

一样的数据，AOF 文件可能比 RDB 还要大，并且AOF 的性能要求更高。

# 比较

RDB 更适合做全量复制，AOF 更适合做增量复制。
