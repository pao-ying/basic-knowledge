# key 同一时间过期

如果 key 过期时间过于集中，则在过期的那个时间，redis 可能会出现卡顿，严重的话会直接出现缓存雪崩，所有建议过期时间设置为随机值，使得过期时间分散。

# redis 分布式锁

使用 `setnx` 命令抢锁，再用 `expire` 命令设置过期时间防止忘记释放锁。

如果担心 `setnx` 后出现意外，导致没有释放锁，可以使用 `setex` 抢锁的同时设置过期时间。

# 查找已知前缀的 key

使用 `keys` 指令可以扫出指定模式的 key 列表。

由于 keys 指令会阻塞线程一段时间，所以可以使用 `scan` 命令，但是可能会有重复概率，在客户端做去重操作就可以了，总体花费时间会比 keys 长。

# redis 实现异步队列

使用 list 结构，rpush 生产消息，lpop 消费消息。当lpop 没有消息时，适当 sleep 一段时间。

如果不使用 sleep ，也可以使用 **blpop**，在没有消息时，会阻塞直到消息的到来。 

如果要**生产一次，消费多次**，可以使用 **pub/sub主题订阅模式**，可以实现 1:N 的消息队列。

对于 pub/sub 主题订阅消息，如果消费者下线，则生产的消息就会丢失，的使用专业的消息队列如 rocketMQ。

# redis 实现延时队列

使用 `sortedset`，拿**时间戳**作为**score**，消息内容作为 key，调用 zadd 来生产消息，消费者使用 `zrangescore` 命令来获取 N 秒之前的数据，轮询进行处理。

# redis 持久化

**RDB做镜像全量持久化**，**AOF做增量持久化**。

RDB耗时较长，不够实时，在停机时会有数据丢失，所以需要 AOF 来配合使用。在 redis 重启时，会使用 RDB 持久化文件重新构建内存，再使用 AOF 放进近期的操作指令来实现完整恢复重启之前的状态。

## 机器停电会如何

取决于 AOF 日志的 sync 属性的配置，如果不要求性能，在每条指令时都会 sync 一下硬盘及不会丢失数据。但是一般都是定时 sync，即 1s1次，这个时候最多丢失 1s 的数据。

# pipeline好处

可以将多次 IO 往返时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。使用**redis-benchmark**进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是**pipeline**批次指令的数目。

# redis同步机制

redis 使用**主从同步**，**从从同步**。

第一次同步时，主节点做一次 **bgsave**，并同时将后续操作写入内存 buffer，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。

# redis进群及高可用

Redis 哨兵着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务。

Redis cluster 着眼于扩展性，在单个 redis 内存不足时，使用 cluster 进行分片存储。