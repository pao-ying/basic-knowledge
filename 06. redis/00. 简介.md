# 简介

redis是高性能key-value数据库，对数据的操作都是原子级别的

# 为什么使用redis

1. 性能

   当遇到需要频繁查询，且不频繁变动的SQL，就适合将数据放入缓存中。这样后面的请求就可以去缓存中读取，使得请求能够迅速得到响应

2. 并发

   在大并发的情况下，所有请求都直接访问数据库，数据库会出现异常。使用redis**作为一个缓冲操作**，让请求先访问到redis，而不是直接访问数据库。

# 为什么不适用map而是用redis

1. 缓存分为本地缓存和分布式缓存，Java的map随着jvm的销毁而结束，在多实例的情况下，难以保持一致性。
2. 使用 redis 分布式缓存，多实例可以使用同一份缓存数据，多实例具有一致性

# 优缺点

## 优点

1. 基于**内存**，读写性能优异

2. redis是**单线程**，避免多线程**切换**开销和**竞争**问题。

   > 单线程是指**处理网络请求**只有单个线程，而redis运行不止一个线程

3. 支持多数据类型

4. 支持持久化，AOF和RDB两种持久化方式

4. 支持事务，redis的所有操作都是原子性的，同时 redis 还支持对几个操作合并后的原子性执行。

5. 采用IO多路复用

6. **支持高可用**。可以使用主从复制，并且提供哨兵机制，保证服务器的高可用。

7. **客户端语言多**。因为Redis受到社区和各大公司的广泛认可，所以客户端语言涵盖了所有的主流编程语言，比如Java，C，C++，PHP，NodeJS等等。

## 缺点

1. 数据库容量受到物理内存限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
2. Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。
3. 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
4. Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。

# 应用场景

1. 缓存**热点数据**，缓解数据库压力
2. 利用redis**原子性**自增操作，实现**计算器功能**。如用户点赞，用户访问数量等
3. 简单消息队列，使用redis的**发布/订阅模式**或者**队列**，实现异步操作。
4. 好友关系，利用**集合**的一些命令，如求交集，并集等。
5. 限速器，如**限制某个用户访问某个API的频率**，如抢购时，防止用户频繁点击。
6. 最新列表
7. 排行榜

# Memcached和redis

1. redis 只是**单核**，memcached是**多核**

   平均每一核上 redis 在存储小数据时比 memcached 性能更高。

   而在 100k 以上的数据中，memcached 性能高于 redis，虽然 redis 最近也在存储大数据的性能上进行优化，但是比起 memecached 要稍逊色。

2. memcached**数据结构**单一，而redis支持多种数据结构

3. memcached不支持**数据持久化**，断电或重启数据消失；redis支持数据持久化和**数据恢复**。

4. redis 支持 cluster 模式，而 memcached 没有原生的集群，要依靠客户端实现往集群中分片写入数据

# redis为什么快

1. 基于内存操作
2. 单线程，避免了频繁的上下文切换消耗
3. 采用了**IO多路复用**机制，非阻塞IO

# 为什么使用单线程

1. 避免过多的上下文开销

   如果是单线程则可以规避进程内频繁的线程切换开销，因为程序始终运行在进程中单个线程内，没有多线程切换的场景。

2. 避免同步机制的开销

   如果 Redis 选择多线程模型，又因为 Redis 是一个数据库，那么势必涉及到底层数据同步的问题，则必然会引入某些同步机制，比如锁。

3. 简单可维护

# redis和数据库如何保持一致性

对于数据库有**强一致性**要求的，不使用缓存。

除此之外，采用**正确的更新策略**，先更新数据库，再删除缓存。如果存在删除缓存失败问题，则采用补偿措施，如**消息队列**。

# 缓存穿透和缓存雪崩

## 缓存穿透

即黑客故意请求缓存中**不存在的数据**，导致所有请求都落在了数据库上。

解决方法：

- 利用**互斥锁**，缓存失效时，获得了锁才可以访问数据库

- **异步更新策略**

  无论key是否取到值，都返回value。value值有一个**缓存失效时间**，缓存过期，**异步**一个线程去读数据库，更新缓存。

- **有效的拦截机制**

  如**布隆过滤器**，迅速判断key是否是合法有效的。
  
  他的原理也很简单就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return。

## 缓存击穿

**缓存击穿**是指一个**Key非常热点**，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。

解决方法

- 设置热点数据永远不过期，或者加上互斥锁

## 缓存雪崩

即缓存在同一时间大面积失效，结果所有请求都落在了数据库上。

解决方法

- 给缓存的**失效时间加上随机值**，**避免群体失效**。

- 使用**互斥锁**，但是吞吐量下降

- **双缓存**

  使用两个缓存，缓存A 和缓存B。

  - 缓存A读取数据，有则返回
  - A没有数据，从B**直接返回**数据，并且异步启动线程查询数据库
  - 同时更新缓存A和缓存B


# redis与MySQL

## 类型上

mysql 是关系型数据库

redis 是缓存数据库

## 作用上

MySQL 用于**持久化**存储到硬盘上，速度较慢

redis 用于存储**较为频繁**的数据到缓存上，速度较快。

## 使用

两者一般都是配合使用。

