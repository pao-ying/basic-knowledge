Redis 支持三种集群方案

- 主从复制模式
- Seninel (哨兵) 模式
- Cluster 模式

# 为什么需要集群

- 单机无法保证高可用，需要引入多实例来提供高可用性
- 单机能够提供高达 8W 左右的QPS，再高的QPS则需要引入多实例
- 单机能够支持的数据量有限，处理更多的数据需要引入多实例；
- 单机所处理的网络流量已经超过服务器的网卡的上限值，需要引入多实例来分流。

# 主从复制模式

![img](..\img\1460000022808581)

## 作用

> 通过 redis 持久化，可以保证服务器重启的情况下不会丢失数据，因为持久化会把内存数据存储在硬盘上，重启会在硬盘上加载数据。但是如果服务器硬盘故障，就会丢失数据。

为了避免**单点故障**，做法是将数据库的数据复制多个副本在不同服务器上，即使一个服务器挂了，其它服务器也能够继续提供服务。

**Redis 提供的主从复制能够实现当一台数据库中的数据更新后，将更新同步到从数据库中。**

其中，数据库分为 主数据库 (master) 和 从数据库 (slave)。**主数据库负责写操作**，当写操作导致数据改变时同步到从数据库；**从数据库负责写操作**，并接受主数据库同步来的数据。一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。

## 目的

- 实现读写分离，分担 master 的读写压力
- 方便做**容灾恢复**

## 原理

![img](..\img\1460000022808583)

- 从数据库启动后，连接主数据库，发送 **SYNC** 命令

- 主数据库执行 **BGSAVE** 命令生成 **RDB** 文件并使用缓冲区缓冲命令执行之后的写操作。

- 主数据库将生成的 **RDB** 文件发送给所有从数据库，从数据库**丢弃所有旧数据**载入收到的 **RDB** 文件。

- 主数据库发送缓冲区的写操作，从数据库接收写操作并执行，至此，**从数据库初始化完成**

- 之后，主数据库每执行一次写操作就会向从数据库发送，从数据库接收并执行写命令。

- 如果出现断开重连后，2.8之后版本会将断线重连的命令传给从数据库，**增量复制**

  > 主从刚刚连接时，进行**全量复制**；全同步结束后，进行增量复制。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，首先会进行增量同步，如果不成功，要求从机进行全量同步。

## 优点

- 读写分离，Master 负责写操作，Slave 负责读操作，能够减轻单机模式下的读写压力
- Slave 可以接受其它 Slave 的连接和同步请求，可以有效分担 Master 的同步压力
- Master 为 Slave 提供服务是以非阻塞的形式，所以在 **Master-Slave** 同步期间，Master 依然能够处理客户端提交的查询或者修改。
- Slave 为 Slave 数据同步服务也是以非阻塞的形式，所以同步期间，Master 依然能够处理客户端提交的查询请求。

## 缺点

- 不具备**自动容错和恢复**的功能，主机或者从机的宕机都会导致前端读写的失败，需要机器重启或者手动切换前端的 IP 才能恢复，即需要人工介入。
- 如果 Master 宕机且部分数据没有及时同步到从机也会造成数据不一致的问题。
- 很难支持在线扩容。

> 如果多个 Slave 断线了，需要重启的时候，尽量不要在同一段时间内重启，因为只要 Slave 重启，就会发送 sync 请求和主机进行全量同步，多个 Slave 重启会使得 Master IO 请求激增而宕机

# 哨兵Sentinel模式

## 问题

使用主从模式时，当 Master 宕机时，需要手动得将从服务器切换为主服务器，需要人工干预，造成一段时间服务不可用。

**哨兵是一个独立的进程，作为进程会独立运行。其原理就是哨兵通过发送命令，等待 redis 服务器响应，从而监控多个 Redis 服务。**

![单哨兵](..\img\1460000022808580)

## 作用

- 通过给 **Master 和 Slave** 发送命令，监控 Redis 服务器状态
- 当哨兵检测到 master 宕机后，会自动将 slave 切换回 master，通过 **发布订阅模式** 通知其它从服务器，修改其 master

## 多哨兵

单哨兵监控可能会出现问题，使用多哨兵进行监控，多哨兵之间还会进行监控，形成了多烧饼模式。

![多哨兵](..\img\1460000022808582)

## 故障切换过程

若 master 宕机，哨兵1检测到了，此时不会马上执行 **failover** 过程，仅仅是哨兵 1 主观认为 master 宕机了，这个现象称之为 **主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次**投票**，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**客观下线**。

## 哨兵功能

- 集群监控：负责监控 master 和 slave 是否正常
- 消息通知：如果某个 redis 有故障，则烧饼负责发送消息作为报警
- 故障转移：如果 master 挂掉了，会自动转移到 slave 上
- 配置中心：如果故障转移发生，通知 client 客户端刷新 master 地址。

## 哨兵工作模式

- 每个哨兵**每秒**向 master, slave, 其它哨兵发送 ping 命令。

- 如果响应时间超过了指定的事件，则被标记为 **主观下线**。

- 如果 master 主观下线，则监视这个 master 的哨兵就**每秒一次**确认 master 进入了主观下线状态。当足够数量哨兵确认后，master 进入**客观下线**状态。

- 当 master 客观下线，哨兵向 master 下的所有 slave 以 **每秒1次** 发送 info 命令

  > 一般情况下，哨兵会以 **10秒一次** 向 master 和 slave 发送 info 命令

- 如果没有足够的哨兵同意master客观下线，则master客观下线的状态会被移除；若master向哨兵发送ping命令且有回复时，主观下线状态会被移除。

## 数据如何同步

当启动 slave 时，会发送 **psync**  命令给 master，如果 slave 是第一次连接到 master，会触发**全量复制**。master 启动一个线程，生成 RDB 文件，同时将新的写请求存在内存中，RDB 文件生成后，master 会将这个 RDB 发送给 slave，slave 拿到后写进磁盘，然后加载内存，然后 master 将内存的写命令发送给 slave

## 为什么只有两个节点无法工作

哨兵集群必须部署 2 个以上节点。

如果两个哨兵实例，即两个 redis 实例，一主一从的模式。

则 redis 的配置 quorum = 1，表示一个哨兵认为 master 宕机即可认为 master 已经宕机。

但是如果机器 1 宕机了，则哨兵1和master都宕机了，虽然哨兵2知道master宕机了，但是这个时候，需要 majority，也就是大多数哨兵都是运行的，2个哨兵的 marjority 就是2 （2的majority=2，3的majority=2，5的majority=3，4的majority=2），2个哨兵都运行着，就可以允许执行故障转移。

但此时哨兵1没了就只有1个哨兵了了，此时就没有majority来允许执行故障转移，所以故障转移不会执行。

## 优点

- 哨兵模式基于主从模式，继承了主从模式的优点
- 主从可以自动切换，系统更加健壮，可用性更高。

## 缺点

- redis 较难支持在线扩容，在集群容量达到上线时扩容会变得复杂

# Cluster 集群模式

Redis Cluster是一种服务器 Sharding 技术，3.0版本开始正式提供。

Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，

所以在 redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，**也就是说每台 Redis 节点上存储不同的内容**。

![image-20200531184321294](..\img\1460000022808584)

在这个图中，每一个蓝色的圈都代表着一个 redis 的服务器节点。它们任何两个节点之间都是相互连通的。客户端可以与任何一个节点相连接，然后就可以访问集群中的任何一个节点。对其进行存取和其他操作。

## 集群数据分片

Redis 集群没有使用一致性 hash，而是引入了哈希槽【hash slot】的概念。

Redis 集群有**16384** 个哈希槽，每个 key 通过 **CRC16 校验**后对 16384 取模来决定放置哪个槽。集群的每个节点负责一部分hash槽，举个例子，比如当前集群有3个节点，那么：

- 节点 A 包含 0 到 5460 号哈希槽
- 节点 B 包含 5461 到 10922 号哈希槽
- 节点 C 包含 10923 到 16383 号哈希槽

这种结构很容易添加或者删除节点。

- 比如如果我想新添加个节点 D ， 我需要从节点 A， B， C 中得部分槽到 D 上。

  增加一个D节点的结果可能如下：

  - 节点A覆盖1365-5460
  - 节点B覆盖6827-10922
  - 节点C覆盖12288-16383
  - 节点D覆盖0-1364,5461-6826,10923-1228

- 如果我想移除节点 A ，需要将 A 中的槽移到 B 和 C 节点上，然后将没有任何槽的 A 节点从集群中移除即可。

由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态。

在 Redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是 cluster，可以理解为是一个集群管理的插件。当我们的存取的 Key到达的时候，Redis 会根据 CRC16 的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。

## redis集群主从复制

为了保证**高可用**，即使得集群在一部分节点下线或者无法与集群的大多数（**majority**）节点进行通讯的情况下， 仍然可以正常运作。

redis-cluster集群引入了主从复制模型，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点 A 和它的从节点 A1 都宕机了，那么该集群就无法再提供服务了。

## 一致性

Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作：第一个原因是因为集群是用了异步复制. 写操作过程:

1. 客户端向主节点B写入一条命令.
2. 主节点B向客户端回复命令状态.
3. 主节点将写操作复制给他得从节点 B1, B2 和 B3

主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 

## 特点

- 所有的 redis 节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。
- 节点的 fail 是通过集群中超过半数的节点检测失效时才生效。
- 客户端与 Redis 节点直连，不需要中间代理层.客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。