# 过期策略

- 惰性删除

  只有在使用key时检查数据是否过期。对CPU友好，但是可能会产生大量过期的key没有删除。

- 定期删除

  每隔一段时间抽取**一部分**的key进行删除。并且redis会通过**限制删除时间和频率**来减少删除操作对CPU的影响。

定期删除对内存更加友好，惰性删除对CPU更加友好。redis采用**定期删除+惰性删除**策略。

但是仍然会漏掉很多过期的key，所以采用**redis内存淘汰机制**

# 内存淘汰机制

应对当**使用内存达到限制值**的情况

- volatile-lru

  从**设置过期时间**的数据集中删除最近最少使用的数据

- volatile-ttl

  从**设置过期时间**的数据集中删除即将要淘汰的

- volatile-lfu

  从**设置过期时间**的数据集中删除最近最不经常使用的数据

- allkeys-lru

  当**内存不足**时，删除最少使用的key

- allkeys-random

  当**内存不足**时，随机删除某个key

- allkeys-lfu

  当**内存不足**时，删除最近最不经常使用的数据

- no-eviction

  当**内存不足**时，写入操作会报错

Redis有了`LRU`之后，为什么还需要`LFU`呢？因为Redis作者发现就算提高采样数量或者pool的大小，也无法再提高缓存命中率，而LFU算法能起到更好的效果。

> LFU近似于LRU，它使用一个概率计数器（morris counter），用来估计访问频率；counter的计数有两个特点，1.随着访问次数的增加，counter的计数会越来越缓慢（counter最大值为255），2.随着时间的流逝，counter会逐渐衰减。淘汰时也会有一个pool，也采取与LRU类似的方式，但是排序是按照计数从大到小排列（越靠后越容易被淘汰）

**为什么Redis不采用标准LRU算法**：

标准LRU算法为了达到查找和删除的时间复杂度一般采用`hash表`和`双向链表`结合的数据结构。这样会增加额外的内存占用。
