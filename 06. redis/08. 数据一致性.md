# 一致性问题

- 读数据时，先从缓存中读取，没有则从数据库中读取，读回来之后更新缓存。
- 写数据时，不论是 redis 先写，还是 mysql 先写，都会造成不一致问题。

根据写入顺序不同可以分为两种

## 先删缓存，再更新数据库

> 线程 A 写数据，线程 B 读数据。当 A 把缓存删除时，线程 B 读取数据，发现没有缓存，即未命中，则从数据库中读取，并更新到缓存中，这时候读取到的就是脏数据。

- 先删缓存，当多并发的情况下，很容易出现缓存不命中的情况。
- 则在**缓存到期**之前，缓存中都是脏数据

### 解决策略

**延迟双删**，即在数据库更新完之后，再次删除对应的缓存。这样子可以删除在更新数据库期间将脏数据读进 redis.

## 写先数据库，再删缓存

> 线程 A 读数据，线程 B 写数据。当 A 未命中缓存时，就会去数据库直接读取旧数据，这时候 B 线程写入数据库，再删除了缓存，A 线程再将数据写入缓存。这时候缓存中的就是脏数据。
>
> 但是这种出现的概率较小，因为 A 线程读数据应该会更快返回。

为什么是删除而不是更新：

- 更新缓存的代价较大。
- 更新操作伴随着读操作。可能缓存数据并没有读到，就被下一次写操作更新的数据覆盖。

### 解决策略

每个 mysql 写完之后，延迟一定时间再删缓存。

