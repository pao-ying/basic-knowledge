# socket连接

socket 成为套接字，用于描述IP地址和端口，是一个通信链句柄。应用程序可以通过 socket 发出网络请求和网络应答。

## 文件描述符

文件描述符 fd ，非负整数，是内核为了高效的管理已经被打开的文件创建的索引，内核利用文件描述符来访问文件。

每个 TCP 连接的两端都会关联一个套接字和**该套接字指向的文件描述符**。

<img src="..\img\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI0ODk4MQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom: 67%;" />

## 流程

- 服务端和客户端初始化Socket，得到文件描述符
- 服务端调用bind，将绑定IP地址和端口
- 服务端调用listen，进行监听
- 服务端调用accept，等待客户端连接
- 客户端调用connect，向服务器端的地址和端口发送连接请求
- 服务端accept返回用于传输的socket的文件描述符
- 客户端调用write写入数据，服务端调用read读取数据
- 客户端断开连接时，会调用close，那么服务端read读取数据的时候，就会读到了EOF，黛处理完数据后，服务端调用close，表示连接关闭

需要注意的是，**服务端调用 accept 时，连接成功会返回一个已经完成连接的 socket，后续用来传输数据**。

监听的socket和真正用来传送数据的socket，是两个socket，一个叫做监听socket，一个叫做已完成连接socket。

成功连接建立之后，双方开始通过read和write函数来读写数据，就像一个文件流里面写东西一样。

## 字节序

## 主机字节序

在网络编程中，IP地址和端口号往往是**多字节整数**，多字节整数在不同的硬件结构上字节序不同。字节序指的是对于存储需要多个字节（大于 1 字节）的整数来说，其每个字节在不同的机器内存中存储的顺序。

- 大端序：按照内存的增长方向，先存储多字节整数的最高有效位
- 小端序：按照内存的增长方向，高位数据存储于低位内存中

## 网络字节序

为了在信息传输时，屏蔽掉不同硬件结构上的字节序的差异，TCP/IP协议规定，所有在网络上传输的多字节整数都以大端序编码，所以大端序就是`网络字节序`.

## 函数

### socket()

```c++
int socket(int domain, int type, int protocol);
```

**socket()**用于创建一个socket描述符，对应于普通文件的打开操作，唯一标识一个socket。

- domain，协议域（族）。如 AF_INET(表示 ipv4与端口号), AF_INET(表示ivp6与端口号)
- type, 指定 socket 类型。如 sock_stream, sock_raw等
- Protocol, 指定协议。如 ipproto_tcp, ipproto_udp, ipproto_sctp

### bind()

```c++
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
```

将套接字绑定到要监听的地址和端口组合 "addr:port" 上，绑定了端口的套接字可以作为 listen 函数的监听对象。

- sockfd, 即 socket 描述符
- addr, 一个 const struct sockaddr* 指针，指向要绑定给 sockfd 的协议地址。这个地址结构根据创建 socket 时的协议族决定，可以是 ipv4, ipv6 或者unix 域。
- addrlen, 表示地址的长度

通常服务器启动时会绑定一个地址（IP地址+端口），用于提供服务，客户端可以通过它来连接服务器。而客户端不需要指定，系统会自动分配端口号和自身的IP地址进行组合。所以服务端需要在 `listen` 之前调用 `bind`，而客户端不需要，会在 `connect` 时由系统随机生成一个。

> 在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序

### listen()

```c++
int listen(int sockfd, int backlog);
```

- sockfd, 代表要监听的 socket 描述符
- backlog 代表是相应 socket 可以排队的最大连接数。

socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。

监听已经通过 bind() 绑定了 "addr:port" 的套接字的，套接字就从 close 状态转变为 listen 状态。

<img src="..\img\listen-backlog.png" alt="在这里插入图片描述" style="zoom: 67%;" />

listen() 会维护两个队列

- 未完成连接队列（SYN队列）：接收一个SYN连接请求，处于SYN_RCVD状态。
- 已完成连接队列（Accept队列）：已完成三次握手，处于Established 状态。

### connect()

```c++
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

- sockfd, 表示客户端的 socket 描述符
- addr, 表示服务器的 socket 地址
- addrlen, 表示socket 地址的长度

用于向某个已监听的套接字发起连接请求，也就是发起 TCP 的三次握手过程。

**函数返回一个新的 socket 描述符，客户端通过读写该sockfd来和服务端通信。**

### accept()

```c++
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

- Socked, 服务器的socket描述字
- sockaddr *的指针addr，用于返回客户端的协议地址
- addrlen 为协议地址的长度

读取**已完成连接队列（Accept队列）**中的第一项（读完就从队列中移除），并对此项生成一个用于后续连接的套接字描述符。

**函数返回一个新的连接 socket 描述符，服务端通过这个socket描述符来与被接受连接对应的客户端通信。**

有了新的连接套接字，用户进程/线程（称其为工作者）就可以通过这个连接套接字和客户端进行数据传输，而前文所说的监听套接字（sockfd）则仍然被监听者监听。

accept() 函数是由**用户空间进程**发起，由内核空间消费操作，只要经过 accept() 过的连接，连接将从已完成队列（accept queue）中移除，也就表示 TCP 已经建立完成了，两端的用户空间进程可以通过这个连接进行真正的数据传输了，直到使用 close() 或 shutdown() 关闭连接时的四次挥手，**中间再也不需要内核的参与**。

### send/recv()

send() 函数是将数据从 app buffer 复制到 send buffer 中，recv() 函数则是将 recv buffer 中的数据复制到 app buffer 中。

当然，对于 tcp 套接字来说，更多的是使用 write() 和 read() 函数来发送、读取 socket buffer 数据，这里使用 send()/recv() 来说明仅仅只是它们的名称针对性更强而已。

### close()/shutdown()

通用的 close() 函数可以关闭一个文件描述符，也包括面向连接的网络套接字描述符。

当调用 close() 时，将会尝试发送 send buffer 中的所有数据。但是 close() 函数只是将这个套接字引用计数减 1，只有这个套接字的所有引用计数都被删除，套接字描述符才会真的被关闭，才会开始后续的四次挥手过程。

> 对于父子进程共享套接字的并发服务程序，调用 close() 关闭子进程的套接字并不会真的关闭套接字，因为父进程的套接字还处于打开状态，如果父进程一直不调用 close() 函数，那么这个套接字将一直处于打开状态，将一直进入不了四次挥手过程。

而 shutdown() 函数专门用于关闭网络套接字的连接，和 close() 对引用计数减 1 不同的是，它直接掐断套接字的所有连接，从而引发四次挥手的过程。可以指定3种关闭方式：

1. 关闭写。此时将无法向 send buffer 中再写数据，send buffer 中已有的数据会一直发送直到完毕。
2. 关闭读。此时将无法从 recv buffer 中再读数据，recv buffer 中已有的数据只能被丢弃。
3. 关闭读和写。此时无法读、无法写，send buffer 中已有的数据会发送直到完毕，但 recv buffer 中已有的数据将被丢弃。

无论是 shutdown() 还是 close()，每次调用它们，在真正进入四次挥手的过程中，它们都会发送一个 FIN。

# accept在哪一步

<img src="..\img\socket-accept.png" alt="在这里插入图片描述" style="zoom:50%;" />

客户端 connet 成功返回是在第二次握手，服务端 connect 成功返回是在第三次握手。

# socket断开

![在这里插入图片描述](..\img\socket-close.png)

1. 客户端调用 close，向服务端发送 FIN 报文，进入 fin_wait_1 状态

2. 服务端接收 FIN，TCP 协议栈会为 FIN 报文添加一个 EOF 结束标识符到接收缓冲区中，应用程序可以通过 read 调用来感知  FIN 包。

   这个 EOF 会放在其它一排队等候的其它已接受的数据之后，意味着服务端要处理这个异常情况，因为 EOF 表示连接上再无额外数据到达。此时服务端发送 ack 包，并进入 close_wait 状态。

3. 客户端接收到 ack 包后，进入 fin_wait_2 状态

4. 当处理完数据后，读到了 EOF，于是调用 **close** 关闭套接字，给客户端发送 FIN 包，之后处于 last_ack 状态

5. 客户端接收到 fin 包之后，进入 time_wait 状态，并发送 ack 包给 服务端
6. 服务端进入 close 状态，客户端经过 2MSL 后进入 close 状态。
