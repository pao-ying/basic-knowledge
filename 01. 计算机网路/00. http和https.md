# SSL连接

SSL全名`Secure Sockets Layer`，即安全套接层协议层。SSL协议指定了一种在应用程序协议（如http, telenet, nmtp和ftp等）和TCP/IP协议之间**提供数据安全性分层机制**。

TLS(Transport Layer Security)**传输层安全**是IETF在SSL3.0基础上设计的协议，实际上相当于SSL的后续版本。

![img](..\img\v2-d050edfb2dbf0501562764efc4a001a3_720w.jpg)

SSL/TLS是一个安全通信框架，上面可以承载HTTP协议或者SMTP/POP3协议等。

# HTTP和HTTPS

- http使用端口是80，https使用的端口是443.
- http协议是运行在tcp协议之上，https是运行在TCP + SSL协议之上。
- http是进行明文传输的，而https会**对传输的内容进行加密，并且可以互相验证身份**。

```
SSL协议指定了一种在应用层协议，如http, telenet, nmtp, ftp等和TCP/IP协议之间提供数据安全性分层的机制。
```

# HTTP 版本

## HTTP1.0：

### 特性

- **无状态**：服务器不跟踪不记录请求过的状态
- **无连接**：浏览器每次请求都需要建立TCP连接

### 缺陷

- 无法复用连接。每次发送请求都需要进行TCP连接，导致网络的利用率非常低
- 队头阻塞。由于下一个请求必须在前一个请求响应之后才能发送，就会导致阻塞后面的请求。

## HTTP1.1：

- 长连接。通过设置 `connection: keep-alive` 保持连接不断开，可以提高网络利用率。

- 支持管道化。管道化使得请求能够“并行”传输。

  > 响应的主体是一个html页面，页面中包含了很多img，这个时候keep-alive就起了很大的作用，能够进行“并行”发送多个请求

  但是这不是真正的并行，服务器必须按照**客户端请求的先后顺序**依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。

  也就是说，HTTP管道化可以让我们把先进先出队列从客户端（请求队列）迁移到服务端（响应队列）。客户端同时发了两个请求分别来获取html和css，假如说服务器的css资源先准备就绪，服务器也会先发送html再发送css。只有等到html响应的资源完全传输完毕后，css响应的资源才能开始传输。

  即不允许同时存在两个并行的响应。

  > 在 google 上看到的并行加载资源，是因为浏览器允许打开多个TCP的会话。

- 新增了一些请求方法 put, delete, options

- 新增了一些请求头和响应头

## HTTP2.0：

### 概念

- **帧**：HTTP2.0数据通信的最小单位消息
- **流**：用于连接的虚拟通道，可以承载双向消息，每个流都有唯一的整数ID
- **消息**：与逻辑消息对应的完整的一系列数据帧

### 特性

- **二进制分帧**

  采用二进制的格式传输数据，而非HTTP1.x的文本格式。二进制格式解析速度更高效

- **多路复用**

  - **同域名**下所有通信都在单个连接中完成
  - 单个连接可以承载**任意数量**的双向数据流
  - 数据流以消息的形式发送，消息由帧组成，可以**乱序发送**，因为根据帧首部的**流标识**重新组装

  HTTP2.0实现了真正的**并行传输**，能够在一次TCP请求中进行任意次HTTP请求。

- **头部压缩**

  在 HTTP1.x中，头部元数据都是以文本形式传输的，会给单次请求增加500-800字节的负荷。

  HTTP2.0使用 **encoder** 减少要传输的 header 大小，同时通讯双方各自 **cached** 一份 header fields 表，可以避免重复的 header 传输，又减少了需要传输的大小。高效的压缩算法可以很大的压缩`header`，减少发送包的数量从而降低延迟。

- **服务器推送**

  服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送**RST_STREAM**帧来拒收。

# SSL/TLS协议

- 客户端发送请求
- 服务端将证书发给客户端
- 客户端会对证书进行检查，查看是否是可信任的机构颁布的，或者域名是否对等，是否过期等。如果证书没有问题，则客户端从证书中取出服务器的公钥，并对传输的数据进行加密。
- 服务端再使用私钥对传输的数据进行解密。

# http传输方式

- GET 获取资源

- POST 请求

- PUT 请求更新

- HEAD 获取报文首部

  与 GET 方法一样，只不过不返回报文主题部分，用于确认 URI 的有效性及资源更新的日期时间等

- DELETE 删除

  与 PUT 相反，按请求 URI 删除指定内容

- OPTIONS 询问支持的方法

  用来查询针对请求 URI 指定的资源支持的方法

- TRACE 跟踪路径

  是让web服务器端将之前的请求通信还回给客户端的方法

- connect

  	要求用隧道协议连接代理

# 报文结构

## request

- 第一部分是**请求行**

  包含：**请求方式、请求地址、请求协议版本**

- 第二部分是**请求头部**

  ```
  User-Agent: ...
  Host: ...
  ```

- 第三部分是**请求体**，但只有POST请求有

## response

- **状态行**

  包含：**协议、响应码（状态码）、状态码描述**

- 响应头部

- **响应正文**

![图片描述](..\img\bVYQcs)

# HTTP工作流程

1. 地址解析

   通过标准的URL来请求指定服务器中指定的服务

2. 封装HTTP请求

   将URL和本机信息封装在HTTP请求包上

3. 封装TCP包

   封装TCP包,**建立TCP连接**

4. 客户端向服务器发送 HTTP 请求

5. 服务器端响应 HTTP 请求，客户端得到 HTML 代码

6. 浏览器解析 HTML 代码，并请求 HTML 代码中的资源

7. 关闭 TCP 连接，浏览器对页面进行渲染呈现给用户

# HTTP协议与TCP/IP协议关系

HTTP 是应用层协议，TCP 是传输层协议，IP 是网络层协议。

IP 协议主要是解决网络路由和寻址问题，TCP 协议主要解决在 IP 层指上可靠的传输数据报

# 长连接/短连接

## TCP 短连接

client 向 server 发起连接请求，server 接收到请求后双方建立连接。当**一次请求**完成之后，发起 closed 请求，关闭连接。

## TCP 长连接

`Keep-Alive`

client 向 server 发起连接请求，server 接收到请求后双方建立连接。但是当双方完成一次请求之后，它们之间的连接不会主动关闭，后续的操作还会继续使用这个连接。

使用 **TCP 保活计时器**可以验证客户端的状态。假定给定连接 **2 小时**内无动作，则服务器向客户端发送**探测报文**，则客户端会有以下状态：

- 客户端响应正常，则保活计时器复位
- 客户端不能响应，则服务器总共发送 **10 次**探测报文，每个间隔 **75 秒**，如果没有任何一个响应，则关闭连接。

### 守护进程

**Httpd守护进程**，一般都提供了**keep-alivetimeout**时间设置参数。一个http产生的tcp连接在传送完最后一个响应后，还需要hold住 keepalive_timeout秒后，才开始关闭这个连接。如果守护进程在这个等待的时间里，一直没有收到浏览发过来http请求，则关闭这个http连接。

# Keep-Alive

## HTTP Keep-Alive

在HTTP 1.0以前，每个http请求都要求打开一个**TCP socket连接**，并且使用一次之后就断开这个TCP连接，这会导致频繁地创建和销毁TCP。HTTP 1.1通过使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。

## TCP Keep-Alive

这是TCP协议栈为了**检测连接状况的保活机制**，当TCP空闲一定时间后会发送心跳包给对方，如果对端回复ACK后，就认为对端是存活的，重置定时器；如果对端回复RST应答（对端崩溃或者其他原因，导致的复位），那就关闭该连接；如果对端无任何回应，那就会出发超时重传，**直到达到重传的次数**，如果对端依然没有回复，那么就关闭该连接。

# http 是无状态的

> 无状态是指下一次传输可以“记住”这次传输信息的能力

- 同一个 URL 请求没有上下文关系
- 每次请求都是独立的，和之前、之后的都没有直接关系
- 服务器没有保存客户端状态，每次请求都需要带上客户端的状态。

# socket/http

HTTP 协议对应于应用层，是基于 `TCP/IP` 协议的。而 `socket` 是对 `TCP/IP` 协议的封装，Socket 本身并不是协议，而是一个调用接口，通过 `socket` ，才可以调用 `TCP/IP` 协议。

## http 连接

HTTP 连接的特点就是客户端发送的请求都需要服务器响应，在请求结束后，会主动释放连接，从建立连接到释放连接的过程称之为“一次连接”。

## socket连接

socket 是通信的基石，是支持 `TCP/IP` 协议网络通信的基本单元。包含有：连接协议、本地 IP、本地协议端口、远程 IP、远程协议端口。

`socket` 连接需要两个一对套接字，一个位于客户端 `clientSocket`，一个位于服务端 `serverSocket`。

`socket` 连接三步骤：服务器监听、客户端请求、连接确认。

- 服务端监听

  服务端套接字负责监听，等待客户端的请求连接

- 客户端请求

  客户端套接字提出连接请求，指出服务端的 IP 地址和对应端口，向服务端套接字发出请求。

- 连接确认

  当服务端套接字接收到客户端请求时，就响应客户端套接字请求，建立一个新的进程。

# HTTP服务器模块

1. soket 连接，监听某个端口
   1. 建立服务端和客户端之间的连接
   2. 从 socket 读数据
   3. 从 socket 写数据
2. 解析 http 请求
3. 生成 http 响应
4. 将响应写回给客户端
