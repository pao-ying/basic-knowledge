# AQS回顾

`AQS`是一个抽象类，所以不能直接实例化，当我们需要实现一个自定义锁的时候可以去继承`AQS`然后重写**获取锁的方式**和**释放锁的方式**还有**管理state**，而`ReentrantLock`就是通过重写了`AQS`的`tryAcquire`和`tryRelease`方法实现的`lock`和`unlock`。

# 结构

`ReentrantLock` 继承自 `Lock`，然后有三个内部类 `Sync`, `FairSync`, `NonFairSync`, 其中 `FairSync` 和 `NonFairSync` 继承自`Sync`，这两个类分是实现公平锁和非公平锁的。

通过`Sync`重写的方法`tryAcquire`、`tryRelease`可以知道，**`ReentrantLock`实现的是`AQS`的独占模式，也就是独占锁，这个锁是悲观锁**。

`ReentrantLock` 通过变量`Sync`来指向 `Sync`的子类，也就是决定使用公平锁还是非公平锁。

# 非公平锁原理

```java
ReentrantLock lock = new ReentrantLock();
```

## lock方法获取锁

1. `lock` 方法使用 **CAS** 方法设置 `state` 的值，如果`state`等于期望值`0`(代表锁没有被占用)，那么就将`state`更新为`1`(代表该线程获取锁成功)，，然后执行`setExclusiveOwnerThread`方法直接将该线程设置成锁的所有者。
2. 如果`CAS`设置`state`的值失败，即`state`不等于`0`，代表锁正在被占领着，则执行`acquire(1)`。调用子类实现的 `tryAcquire`后，调用 `nonfairTryAcquire`
   1. `nonfairTryAcquire`方法首先调用`getState`方法获取`state`的值，如果`state`的值为`0`(之前占领锁的线程刚好释放了锁)，那么用`CAS`这是`state`的值，设置成功则将该线程设置成锁的所有者，并且返回`true`。
   2. 如果`state`的值不为`0`，那就**调用`getExclusiveOwnerThread`方法查看占用锁的线程是不是自己**，如果是的话那就直接将`state + 1`，然后返回`true`。
   3. 如果`state`不为`0`且锁的所有者又不是自己，那就返回`false`，**然后线程会进入到同步队列中**。

## unlock锁的释放

1. 判断当前线程是不是锁的所有者，如果不是抛出异常。
2. 之后判断是否锁之后 `state` 是否为0，如果是，则代表**锁有没有重入**，然后将锁的所有者设置成`null`且返回`true`。此时 state = 0，唤醒同步队列中的后继节点进行锁的获取。如果不是，则代表锁发生了重入，则不唤醒同步队列。

# 公平锁原理

## lock方法获取锁

1. 获取状态的`state`的值，如果`state=0`即代表锁没有被其它线程占用(但是并不代表同步队列没有线程在等待)，则判断同步队列是否存在线程，如果不存在则直接将锁的所有者设置成当前线程，且更新状态state，然后返回true。
2. 如果state!=0，则则代表锁正在被其它线程占用，判断锁的所有者是不是当前线程，如果是则更新状态state的值，然后返回true，如果不是，那么返回false，即线程会被加入到同步队列中

## unlock方法释放锁

公平锁的释放和非公平锁是一样的，不同的地方就是获取锁。

# lockInterruptibly

**`lockInterruptibly`中断式获取锁**

`ReentrantLock`相对于`Synchronized`拥有一些更方便的特性，比如可以中断的方式去获取锁。

会通过 `Thread.interrupted()` 来判断当前线程是否中断，如果为true，则抛出异常。

# tryLock

**`tryLock `超时等待方式获取锁**

`ReentrantLock`除了能以能中断的方式去获取锁，还可以以超时等待的方式去获取锁，所谓超时等待就是线程如果在超时时间内没有获取到锁，那么就会返回`false`，而不是一直"死循环"获取。

1. 判断当前节点是否已经中断，已经被中断过则抛出异常，如果没有被中断过则尝试获取锁，获取失败则调用`doAcquireNanos`方法使用超时等待的方式获取锁。

2. 将当前节点封装成独占模式的节点加入到同步队列的队尾中。

3. 进入到"死循环"中，**但是这个死循环是有个限制的，也就是当线程达到超时时间了仍未获得锁，那么就会返回`false`，结束循环**。这里调用的是`LockSupport.parkNanos`方法，在超时时间内没有被中断，那么线程会从**超时等待状态转成了就绪状态**，然后被`CPU`调度继续执行循环，**而这时候线程已经达到超时等到的时间，返回false**。

# 等待通知机制

`ReentrantLock`通过`Condition`对象，也就是**条件队列**实现了和`wait`、`notify`、`notifyAll`相同的语义。

- 线程执行`condition.await()`方法，可以将将**节点从同步队列转移到条件队列中**。
- 线程执行`condition.signal()`方法，可以将**节点从条件队列中转移到同步队列**。

因为只有在同步队列中的线程才能去获取锁，所以通过`Condition`对象的`wait`和`signal`方法能实现等待/通知机制。
