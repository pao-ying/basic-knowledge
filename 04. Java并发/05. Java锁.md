# 可重入锁

可重入锁又称为递归锁。

## 描述

当一个线程获取了某个对象的锁，此时该对象的锁被该线程持有，但是当该线程还要继续获得该对象的锁是，可重入锁还可以获得。

## 原理

每个锁都有一个**计数器**和**持有者线程**。当计数器值 = 0 时，某个线程获取锁，则计数器 + 1，并且将该线程作为该锁的持有者。当线程再次获取该锁时，会判断是否是持有者，如果是持有者则，计数器 + 1，否则不允许。当退出一次同步代码块时，计数器 - 1。当计数器= 0 时，锁被释放。

# 可中断锁

## 描述

某个线程持有锁时，当另一个线程尝试获取锁，如果等待时间过长，可以中断执行其它事情。

其中 `Synchronized ` 不是可中断锁，`ReentrantLock` 是可中断锁。

## 实现

ReentrantLock.tryLockInterrputibly() 方法。

在线程等待获取锁过程中，可以中断等待。

# 公平锁

- 公平锁能够以请求锁的顺序来获取锁。
- 非公平锁无法保证按请求顺序获取锁，这样可能导致某些线程永远获取不到锁

`Synchronized` 就是非公平锁，`ReentrantLock ` 和 `ReentrantReadWriteLock` 默认非公平锁，可以设置成公平锁。

# 读写锁

读写锁将对一个资源的访问分为 2 个锁，即读锁和写锁。

`ReadWriteLock` 就是读写锁接口，`ReentrantReadWriteLock` 实现了这个接口。

通过 `readLock()` 获取读锁，通过 `writeLock()` 获取写锁。

# 自旋锁

自旋锁是**非阻塞锁**，当线程之间的竞争不激烈时，或者说线程保持锁的时间比较短，那么在获取锁时可以不放弃 CPU 时间片，而是轮询的方式直到锁的持有者放弃锁。

> 将一个线程阻塞的代价就是线程的上下文切换。

## 问题

- 过多占据 CPU 时间
- 死锁问题。如在递归问题时，当线程持有锁后再次尝试获取锁就会产生死锁问题。

