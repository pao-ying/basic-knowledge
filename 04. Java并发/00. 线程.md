# 实现线程的方式及其区别

继承**Thread**类和实现**Runnable**或者**Callable**接口

- 继承Thread类后就不能够继承其它类了

- 继承Thread或者实现Runnable接口都是重写**run()**方法

  实现**Callable**接口是重写**call()**方法。

- Callable可以返回返回值和抛出异常

- 继承Tread类访问线程名使用this.getName()。

  后两者使用Thread.currentThread().getName()

```Java
// Thread() -> run()
class Thread1 extends Thread {
    private int n = 5;
    
    @override
    public void run() {
        while(n > 0) {
            sout("name" + this.getName() + n);
            n--;
        }
    }
}
// Runnable() => run()
class Thread2 implements Runnable {
    private int n = 5;
    
    @override
    public void run() {
        while(n > 0) {
            sout("name" + Thread.currentThread().getName() + n);
            n--;
        }
    }
}
// callable() => call()
class Thread3 implements Callable<String> {
    private int n = 5;
    
    @Override
    public String call() throws Exception {
        while(n > 0) {
            sout("name" + Thread.currentThread().getName() + n);
            n--;
        }
    }
}
```

# 为什么使用start()不使用run()

因为start()会执行线程的相应准备工作，然后自动执行run()方法。而直接启动run()方法，是在main()线程下的，会将他当成main()线程下的普通方法去执行，并不会在其它线程下执行，所以不是多线程工作。

## 调用两次start()会发生什么

会抛出**线程状态异常**，在start()方法里面，首先会对线程状态进行判断，代码为

```java
if (threadStatus != 0) {
	throw new illegalThreadStateException();
}
```

其中threadStatus变量初始化为0，如果一个线程调用了之后就不为0了，再次调用时就会抛出异常。

# 线程停止

## 标志位

在run()方法执行完毕后，线程就会停止。但是当run()方法内使用了`while(true)`时，就不会停止，这时候使用标志位来结束run()方法。

```Java
public class ServerThread extends Thread {
    //volatile修饰符用来保证其它线程读取的总是该变量的最新的值
    public volatile boolean exit = false; 

    @Override
    public void run() {
        ServerSocket serverSocket = new ServerSocket(8080);
        while(!exit){
            serverSocket.accept(); //阻塞等待客户端消息
            ...
        }
    }
    
    public static void main(String[] args) {
        ServerThread t = new ServerThread();
        t.start();
        ...
        t.exit = true; //修改标志位，退出线程
    }
}
```

## 使用stop()

已经启用，原因

- 使用stop()会停止run()下的所有剩余工作，包括catch()和finally()，导致请理性工作不能完成。
- 会释放所有的锁，导致数据不一致

## 使用interrupt()

调用 interrupt() 只是用来打了个标记，并不是真的停止线程，而是通知目标进程，希望该进程终止。

- Thread.isInterrupted() // 判断是否被中断
- Thread.interrupted() // 判断是否被中断，并清除中断状态

```Java
public class InterruptThread1 extends Thread{

    public static void main(String[] args) {
        try {
            InterruptThread1 t = new InterruptThread1();
            t.start();
            Thread.sleep(200);
            t.interrupt();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void run() {
        super.run();
        for(int i = 0; i <= 200000; i++) {
            //判断是否被中断
            if(Thread.currentThread().isInterrupted()){
                //处理中断逻辑
                break;
            }
            System.out.println("i=" + i);
        }
    }
    
}
```

# 线程状态转换

## 生命周期

- new

  初始状态，还没有调用start()

- runnable

  可运行状态，Java线程将操作系统中的**就绪ready和运行run称作runnable**

  > 因为当前的操作系统大多数采用**时分多任务操作系统**架构都是使用**时间分片**方式进行抢占式轮转调度。而时间分片非常小，一个线程在CPU上最多运行10-20ms，就会被放入调度队列的末尾等待调度。即从running->ready状态切换的很快，再分就没有意义。

- blocked

  阻塞状态，表示**线程阻塞于锁**

- waiting

  等待状态，表示线程进入等待状态，表示需要等待其他线程做出一些特定动作（**中断或通知**）

- time_waiting

  超时等待状态，不同于waiting，可自动返回runnable状态

- terminated

  终止状态，表示线程执行完毕

![Java 线程状态变迁 ](..\img\Java+线程状态变迁.png)

## 状态转换

线程创建后处于**new**状态，调用`start()`方法后进入**runnable**状态。

当线程执行`wait()`方法后，线程进入**waiting**状态，需要等待其它进程的通知才能回到运行状态。

而**time_waiting**状态相当于在**waiting**状态上添加了超时限制，如`sleep(long millis)或者wait(long millis)`方法可以将线程置于**time_waiting**状态。当超时后会自动回到运行状态。

当线程调用**同步方法**，没有**获得锁**时，线程进入了**blocked**状态。

线程执行完`run()`方法后进入**terminated**状态。

# 线程安全

当多线程访问某个类时，不管运行环境采用何种**调度方式**或者**线程如何交替运行**，在调用代码中不需要额外的**同步或者协同**，这个类都能表现正常行为，那么这个类就是线程安全的。

# wait/notify与sleep

## 异同

- wait释放了锁，sleep没有释放锁
- 都可以暂停线程
- wait通常用于线程间交互，sleep通常用于暂停执行
- wait需要使用notify唤醒。sleep()执行完后自动苏醒。

https://blog.csdn.net/zfy163520/article/details/104947177?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link

## 为什么wait/notify定义在Object

wait()是用来释放锁的，设计在Object类中的原因是，**Java提供的锁是对象级的而不是线程级的**，每个对象都有锁，而线程可以获得这个对象。因此，当线程需要获取某个锁，那么就调用对应对象的wait()方法即可。

而如果定义在Thread上，线程正在等待哪个锁就不确定了。

## 为什么sleep定义在Thread

从sleep的定义可知，**是让线程暂停执行一段时间**，可以理解为sleep()方式是线程级别的，而且sleep方法也**不会释放锁**，所以不满足在锁内使用的意义。