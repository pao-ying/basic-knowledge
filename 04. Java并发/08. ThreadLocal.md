# 简介

ThreadLocal是一个关于创建线程局部变量的类。

通常情况下，**我们创建的变量是可以被任何一个线程访问并修改的**。而**使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改**。主要的作用是为了做**数据隔离**

核心思想：

> ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被`private static`修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。

总的来说，**ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。**

# ThreadLocalMap

ThreadLocalMap 是 ThreadLocal 的静态内部类，当一个线程有多个 ThreadLocal 时，需要一个容器来管理多个 ThreadLocal，ThreadLocalMap 的作用就是**管理线程中多个 ThreadLocal**

ThreadLocalMap 是 Thread 的成员变量，数据结构其实是一个数组，该数组的元素是 Entry 类型。Entry 是一个 k-v 结构，且 k 是 ThreadLocal 的引用，并且对该类型对象的引用是**弱引用**。

# 实现线程隔离

即 Set() 方法是如何实现线程隔离的。

## Set 源码

**`ThreadLocal.set(T value)` 源码**:

- 首先获取当前线程
- 利用当前线程作为句柄调用 **getMap**方法获取**ThreadLocalMap**的对象
- 如果上述ThreadLocalMap对象不为空，则调用 `threadLocalMap的set`方法存储 `<ThreadLocal, T>`键值对 ，否则调用 `createMap()` 创建这个ThreadLocalMap对象并设置值

**其中 `ThreadLocalMap.set(ThreadLocal<?> key, Object value)` 源码**:

1. 首先会计算 ThreadLocal 这个 key 值在数组的下标

2. 通过下标大小遍历 ThreadLocal 内的 一段`tab` 数组，获取每项的 key 值，即 ThreadLocal 对象，当两者匹配时，直接将对应项的 value 设置为 value 参数。如果该项 key 值为 null，说明该项被清理了，调用 `replaceStaleEntry()` 方法进行替换。
3. 如果遍历完之后仍没有匹配元素或者空槽，则创建一个新的 Entry 插入进去
4. 最后检查当前元素数量是否超过容量阈值，即数组大小的三分之二，决定是否扩容。

## Get 源码

**`ThreadLocal.get()`方法源码：**

1. 首先调用 `Thread.currentThread()` 获取当前 `ThreadLocal` 所在的线程，再调用 `getMap()` 获取 `ThreadLocalMap`。
2. 如果 map 不为空，则读取当前 ThreadLocal 中保存的值
3. 如果 map 为空，则对当前线程的 ThreadLocal 初始化，返回当前的 ThreadLocal 对象关联的初值，即 value。

# 用法

```java
private void testThreadLocal() {
    Thread t = new Thread() {
        ThreadLocal<String> mStringThreadLocal = new ThreadLocal<>();
        @Override
        public void run() {
            super.run();
            mStringThreadLocal.set("droidyue.com");
            mStringThreadLocal.get();
        }
    };
    t.start();
}
```



# 使用场景

- 实现单个线程单例以及单个线程**上下文信息存储**，比如交易id等
- 实现**线程安全**，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例
- 方便同一个线程使用某一对象，避免不必要的参数传递
- 全链路追踪中的 traceId 或者流程引擎中上下文的传递一般采用 ThreadLocal
- Spring 事务管理器采用了 ThreadLocal
- Spring MVC 的 RequestContextHolder 的实现使用了 ThreadLocal

# 问题

## 对象存放位置

**存放在栈中。**

在Java中，栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。

## ThreadLocal 实例和值在栈上？

其实不是，因为ThreadLocal实例实际上也是被其创建的类持有（更顶端应该是被线程持有）。而ThreadLocal的值其实也是被线程实例持有。

**它们都是位于堆上，只是通过一些技巧将可见性修改成了线程可见。**

## 真的只能被一个线程访问？

使用**InheritableThreadLocal**可以实现多个线程访问ThreadLocal的值。

## 会导致内存泄露么？

ThreadLocal在保存的时候会把自己当做Key存在ThreadLocalMap中，正常情况应该是key和value都应该被外界强引用才对，但是现在key被设计成WeakReference弱引用了。

这就导致了一个问题，ThreadLocal在没有外部强引用时，发生GC时会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。

> 就比如线程池里面的线程，线程都是复用的，那么之前的线程实例处理完之后，出于复用的目的线程依然存活，所以，ThreadLocal设定的value值被持有，导致内存泄露。

### **解决方式**

在代码的最后使用remove就好了，我们只要记得在使用的最后用remove把值清空就好了。

remove 方法是先获取到当前线程的 ThreadLocalMap，并且调用了它的 remove 方法，从 map 中清理当前 ThreadLocal 对象关联的键值对，这样 value 就可以被 GC 回收了。

### 为什么key要设成弱引用

key不设置成弱引用的话就会造成和entry中value一样内存泄漏的场景。