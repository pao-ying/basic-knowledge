# 总体设计

![图1 ThreadPoolExecutor UML类图](../img/912883e51327e0c7a9d753d11896326511272.png)

## 接口

- Executor 接口

  将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。

- ExecutorService 接口

  - 扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；
  - 提供了**管控线程池**的方法，比如停止线程池的运行。AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。

- AbstractExecutorService 抽象类

  将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。

- ThreadPoolExecutor

  ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。

## 运行机制

![图2 ThreadPoolExecutor运行流程](..\img\77441586f6b312a54264e3fcf5eebe2663494.png)

线程池在内部实际上构建了一个**生产者消费者模型**，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。

线程池的运行主要分成两部分：**任务管理、线程管理**。

- **任务管理部门充当生产者角色**

  当任务提交后，线程池会判断该任务后续的流转

  - 直接申请线程执行该任务
  - 缓冲到队列中等待线程执行
  - 拒绝该任务

- **线程管理部门充当消费者角色**

  线程管理部门统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。

# 生命周期管理

