# AQS原理

## 概况

`AQS`：抽象队列同步器

核心思想：

**如果被请求的资源空闲，则将当前请求资源的线程设置为工作线程，并将共享资源设置为锁定状态。如果被请求的资源被占用，则将暂时获取不到的资源加入到CLH队列中去。**

AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。

## 数据结构

AQS中最基本的数据结构是**Node**，即CLH队列中的节点。

有几个重要的方法和属性值：

- waitStatus, 表示当前节点在队列中的状态
  - 0， Node在初始化时的默认值
  - Cancelled, 为1，当前节点由于超时或者被中断而被取消。一旦节点被取消后，那么它的状态值不在会被改变，且当前节点的线程不会再次被阻塞。
  - Condition, 为 -2，该节点的线程处于等待条件状态,不会被当作是同步队列上的节点,直到被唤醒(signal),设置其值为0,重新进入阻塞状态.
  - propagate,为-3，表示共享模式下的释放操作应该被传播到其他节点。该状态值在doReleaseShared方法中被设置的。
  - Signal, 为 -1，表示线程已经准备好了，就等资源释放了
- thread，表示处于该节点的线程
- pre, 前驱指针
- predecessor, 返回前驱节点，没有的话抛出npe
- nextWaiter, 指向下一个处于CONDITION状态的节点
- next, 后继指针

## 线程两种锁模式

- shared, 表示线程以共享的模式等待锁，如 ReentrantLock
- Excluded, 表示线程正在以独占的方式等待锁，如 Semaphore/CountDownLatch

## 不同状态 state

AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。0表示未获取，1表示已经获取，大于1表示可重入数。提供了三个方法访问这个字段：

- protected final int **getState**(), 获取state的值
- protected final void **setState**(int newState), 设置 State 的值
- protected final boolean **compareAndSetState**(int expect, int update), CAS方式更新state

## 自定义同步器

不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。

- isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。

- tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。

- tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。

- tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。

- tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。

# 资源共享方式

资源共享方式有独占和共享方式，这两种模式的区别就在于`AQS`在唤**醒线程节点的时候是不是传递唤醒**。

## 独占模式

### 同步状态获取

`acquire(int arg)` 方法为 AQS 提供的**模板方法**。该方法为独占式获取同步状态，但是该方法对**中断不敏感**。

```java
public final void acquire(int arg) {
  if (!tryAcquire(arg) &&
      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
    selfInterrupt();
}
```

调用 `tryAcquire(int arg)` 方法，获取成功则设置锁状态并返回 true ，否则获取失败，返回 false 。但是这个方法需要自定义同步器自己实现。

返回 false 后调用 `addWaiter` 方法把当前节点添加到等待队列末尾,并设置为独占模式。`addWaiter` 步骤：

1. 把当前线程包装为node,设为独占模式
2. 尝试快速入队，即调用 `compareAndSetTail` CAS替换当前尾部，在无竞争条件下会成功。如果失败，则调用 `enq` **自旋**重试入队。

把node插入队列末尾后,它并不立即挂起该节点中线程,因为在插入它的过程中,前面的线程可能已经执行完成。所以调用 `acquireQueued()` **自旋**操作尝试获取锁。`acquireQueued` 步骤：

1. 如果它的前继节点为头结点,调用 `tryAcquire()`尝试获取锁,获取成功则返回。
2. 如果没获取到锁,则调用 `shouldParkAfterFailedAcquire` 判断是否应该挂起。该方法步骤：
   1. 调用**前置节点**的 `waitStatus` 方法获取前置节点的 waitStatus
   2. 如果 waitStatus 为 signal，返回 true
   3. 如果 waitStatus > 0，表示已经被取消，则向前循环重新调整链表节点，返回false
   4. 否则 waitStatus 为 0 或者 propagate，然后调用 `compareAndSetWaitStatus` 设置为 signal，返回 false
3. 如果返回为 true 则调用 `parkAndCheckInterrupt()` 挂起当前线程，且返回当前线程的中断状态。

**总结**

AQS模版方法 `acquire` 通过调用子类自定义实现的tryAcquire获取同步状态失败后，调用 `addWaiter` 将线程构造成Node节点，同时将Node节点添加到同步队列对尾，之后调用 `acquireQueued`，让节点以自旋的方法获取同步状态。在节点自旋获取同步状态时，只有其前驱节点是头节点的时候才会尝试获取同步状态；如果该节点的前驱不是头节点，或者该节点的前驱节点是头节点但是获取**同步状态**失败，则判断当前线程需要阻塞。

### 同步状态释放

持有锁的该线程执行释放操作,即head节点中的线程释放锁。

AQS中的release释放同步状态和acquire获取同步状态一样，都是模板方法，tryRelease释放的具体操作都有子类去实现，父类AQS只提供一个算法骨架。

```java
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

在 release 方法中调用 `unparkSuccessor` 方法。`unparkSuccessor` 步骤：

1. 如果该节点的后记节点不为空且不是作废状态，则唤醒这个后继节点
2. 否则从末尾开始寻找合适的节点，如果找到，则唤醒

## 共享模式

### 同步状态获取

AQS提供 `#acquireShared(int arg)` 方法，共享式获取同步状态。首先会调用子类自定义实现的`tryAcquireShared()`获取同步状态失败后，调用`doAcquiredShared` 方法。该方法与独占模式下的 `acquiredQueue` 相似，不同的就是调用 `setHeadAndPropagate` 设置新的头节点，**并根据条件，唤醒下一个节点**。这里和**独占式**同步状态获取很大的不同：通过这样的方式，不断唤醒下一个**共享式**同步状态， 从而实现同步状态被**多个**线程的**共享获取**。

**总结**

当线程调用acquireShared()申请获取锁资源时，如果成功，则进入临界区。获取锁失败时，则创建一个共享类型的节点并进入一个FIFO等待队列，然后被挂起等待唤醒。当队列中的等待线程被唤醒以后就重新尝试获取锁资源，如果成功则唤醒后面还在等待的共享节点，并把该唤醒事件传递下去，即会依次唤醒在该节点后面的所有共享节点，然后进入临界区，否则继续挂起等待。

## 同步状态释放

AQS提供 `#releaseShared(int arg)` 方法，共享式获取同步状态。首先会调用子类自定义实现的`tryReleaseShared()`成功后，调用 `doRealeaseShared()` 方法。与独占方式同步状态释放不同的是，该方法轮询调用 `compareAndSetWaitStatus` 设置头节点的 waitStatus 从 singal 状态变为 0，成功之后再调用 `unparkSuccessor` 方法。

# Semaphore 信号量

`Semaphore` 即可以执行多个线程同时访问某个资源。

```java
// 定义可 20 个线程同时访问资源
Semaphore semaphore = new Semaphore(20);
// 阻塞，直到获取一个 许可
semaphore.acquire();
// 增加一个 许可
semaphore.release();
```

- **公平模式**：调用 `acquire()` 方法的顺序就是请求许可证的顺序，遵循 FIFO
- **非公平模式**：抢占式的。

### 应用场景

为了性能和安全的考量，性能方面限制线程并发数，安全方面进行加锁。

# AQS如何获取锁

AbstractQueuedSynchronizer 是是一个基于FIFO的队列实现的并发控制，队列中的元素通过操作共享资源state来获取和释放锁，state是一个volatile修饰的int类型变量。

以ReentrantLock中独占锁为例，如果有一个线程来获取锁，这时如果队列中没有元素，那就把这个线程加入队列，同时线程申请的数量加入到state变量。如果队列中已经有元素，这个线程入队尾，之后线程中断**等待队列前一个元素**释放锁后唤醒。

# AQS如何释放锁

尝试释放锁(state变量中减去1)，把当前锁的拥有者置空，通知队列中下一个节点。

# CountDownLatch 倒计时器

`CountDownLatch` 基于 AQS，允许 `count` 个线程（单个或多个）阻塞在一个地方，直至所有线程的任务都执行完毕。

### 原理

- 初始化

  ```java
  CountDownLatch latch = new CounDownLatch(100);
  ```

  初始化线程数为 100 的倒计时器，其中默认构造器 AQS 的初始化 state = 100.

- 请求完成

  ```java
  latch.countDown();
  ```

  当一个线程的任务完成时，调用 `countDown()` 方法，实际调用 `tryReleaseShared` 方法以 CAS 操作让 state 减一。

- 阻塞等待

  ```java
  latch.await();
  ```

  阻塞等待 state 的值为 0，若 state = 0，则释放所有等待线程，执行 await() 后面的语句。

### 用法

- 某一线程在开始运行前等待 n 个线程执行完毕。

- 实现多个线程执行任务的最大**并行性**

  并行性，强调的是多线程在某一时刻同时开始执行。初始化一个 `CountDownLatch` ，计数器初始化为 1，多个线程执行前首先 `latch.await()`，当主线程调用 `countDown()` 时，计数器变为0，多线程同时被唤醒。

### 缺点

`CountDownLatch` 是一次性的，计数器的值只在 AQS 构造方法中初始化一次。再次使用时，需要重新创建对象。

# CyclicBarrier 循环栅栏

### 原理

`CyclicBarrier` 是基于 `ReentrantLock` 和 `Condition` ，初始化拦截线程的数量，只有当被拦截（屏障）的线程数量达到这个值时，被拦截的所有线程才会执行。

### 用法

- 初始化

  - 普通初始化

    ```java
    CyclicBarrier barrier = new CyclicBarrier(5);
    ```

  - 高级初始化

    ```java
    CyclicBarrier barrier = new CyclicBarrier(5, () -> {
        System.out.println("--线程达到数量，优先执行--");
    })
    ```

    即当拦截的线程数量到达初始化值时，优先执行定义的方法。

- 阻塞

  ```java
  barrier.await();
  ```

  线程阻塞，只有当 `CyclicBarrier` 阻塞的线程达到值时，才会执行后面的代码。

## CountDownLatch与CyclicBarrier

- CountDownLatch 只能使用一次，而 CyclicBarrier 可以使用多次。
- latch 和 barrier 都可以让多个线程**等待同步**再开始下一步动作，但是 latch 的下一步动作实施者是**当前线程**，而 barrier 的实施者是其它**线程本身**。相当于 latch 需要**被动**调用`countdown()` 让计数器为 0 唤醒其他线程，而 barrier 只需要线程达到数量就能够**主动**唤醒其它线程。

