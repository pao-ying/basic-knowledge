# ThreadPoolExecutor

## 作用

- **降低资源消耗**，重复利用已创建的线程降低**线程创建和销毁**造成的消耗
- **提高响应速度**，当任务达到时，无需等待线程创建而可以直接执行
- **提高线程的可管理性**，可以使用线程池对线程进行统一分配和管理

## 构造方法

```java
    /**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */
    public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量
                              int maximumPoolSize,//线程池的最大线程数
                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
                              TimeUnit unit,//时间单位
                              BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列
                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可
                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
                               ) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

3个最重要的参数

- corePoolSize

  最小可同时运行的线程数

- maxiumPoolSize

  当队列中存放的任务数达到队列容量时，可同时运行的最大线程数

- workQueue

  新任务进来前会先判断是否已经达到核心线程数，如果达到的话，会存放在队列中

其它常见参数

- keepAliveTime

  当线程数大于核心线程数时，多余的空闲线程的存活最大时间为keepAliveTime

- unit

  keepAliveTime的单位时间

- threadFactory

  线程工厂，用来创建线程，一般默认使用

- handler

  饱和策略

## 饱和策略

当同时可运行的线程数达到最大线程数时且队列中已经放满了任务时

- AbortPolicy

  拒绝策略，抛出**RejectedExecutorException**拒绝新任务的处理

- CallerRunsPolicy

  调用执行自己的线程运行任务，也就是直接在**调用execute()方法的线程**中运行被拒绝的任务。

  这种策略会降低新任务的处理速度，影响程序的整体性能。如果系统可以承受此延迟，并且要求任何一个任务都被执行，可以选择该策略。

- DiscardPolicy

  不处理任务，直接丢弃

- DiscardOldestPolicy

  丢弃最早未处理的任务请求

> **默认使用 AbortPolicy**。对于可伸缩的应用，建议使用 CallerRunsPolicy，当线程池被填满时，此策略提供可伸缩的队列。

## 使用

```Java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    CORE_POOL_SIZE,
    MAX_POOL_SIZE,
    KEEP_ALIVE_TIME,
    TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(QUEUE_CAPACITY),
    new ThreadPoolExecutor.CallerRunsPolicy());

for (int i = 0; i < 10; i++) {
    //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）
    Runnable worker = new MyRunnable("" + i);
    //执行Runnable
    executor.execute(worker);
}
//终止线程池
executor.shutdown();
while (!executor.isTerminated()) {
}
System.out.println("Finished all threads");
```

## 流程

首先向线程池提交任务, 判断**核心线程数**是否已满

- 未满, 就直接创建线程执行任务
- 已满, 判断**等待队列**是否已满
  - 未满, 则加入等待队列
  - 已满, 则判断线程池是否已满
    - 未满, 则创建线程执行任务
    - 已满, 则采用拒绝策略

# 对比

## execute()与submit()

- execute()用于提交无返回值任务，无法判断是否执行成功
- submit()用于提交有返回值的任务。会返回`Future`对象，通过`Future.get()`返回值。

## shutdown()与shutdownnow()

- shutdown()关闭线程池，不接受新任务，但是会处理完队列里面的任务
- shutdownnow()关闭线程池，线程状态变为`stop`。线程池终止当前正在运行的任务，并停止处理队列中的任务，返回等待执行的任务list

## isTerminated()与isShutDown()

- isShutDonw()调用shutdon()后为true
- isTerminated()调用shutdown()后所有任务执行完成后返回true

# 工作队列

## ArrayBlockingQueue

有界队列,使用数组实现的**有界**阻塞队列.FIFO排列

## LinkedBlockingQueue

可设置容量, 也可不设置容量. 不设置容量就是无界队列.

吞吐量通常高于ArrayBlockingQueue

newFixedThreadPool使用该队列

## DelayQueue

延迟队列是一个任务定时周期的延迟执行队列, 根据执行时间排序.

newScheduleThreadPool使用该队列

## priorityBlockingQueue

优先级队列, 具有优先级的无界阻塞队列

## SynchronousQueue

同步队列, 不存储元素的阻塞队列, 每个插入操作必须等待另一个进程移除队列, 否则插入操作处于阻塞状态.

CachedThreadPool使用该队列

# 几种常见线程池

## FixedThreadPool

创建固定数量的线程池, 核心线程数和最大线程数相同.

```java
   /**
     * 创建一个可重用固定数量线程的线程池
     */
    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>(),
                                      threadFactory);
    }
```

不推荐使用，因为使用了**LinkedBlockingQueue**，是**无界队列**，运行中的FixedThreadPool**不会拒绝新的任务**，容易导致OOM

## SingleThreadExecutor

创建只有一个线程的线程池, 核心线程数等于最大线程数, 且都为 1 .

```java
   /**
     *返回只有一个线程的线程池
     */
    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>(),
                                    threadFactory));
    }
```

使用了**LinkedBlockingQueue**, 由于该队列是无界队列, 所以同样会造成 OOM 问题.

## CachedThreadPool

CachedThreadPool 的核心线程数为 0, 最大线程数为 Integer.MAX_VALUE. 也就是说如果主线程提交任务的速度高于处理任务的速度, cachedThreadPool 就会不断创建新的额线程.

```java
    /**
     * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。
     */
    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>(),
                                      threadFactory);
    }
```

不推荐使用因为最大线程量integer.max_value，可能会创建大量线程，导致OOM

# scheduledThreadPoolExecutor

使用的**delayQueue**封装了**PriorityQueue**, priorityQueue会对任务进行排序, 执行所需时间短的放在前面先执行, 所需时间相同则先提交的任务先被执行.