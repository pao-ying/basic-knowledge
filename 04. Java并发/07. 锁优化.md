# 锁升级

顺序：偏向锁 -> 轻量级锁 -> 重量级锁

## 偏向锁

指**同步代码块**一直被同一线程所访问时，即不存在多个线程竞争时，那么后序访问会自动获取偏向锁。

> 在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。

通过 CAS 操作将线程存储到**对象头 mark word**中，记录该线程并设置锁状态为偏向锁(101)。线程加锁和释放锁也不需要再通过 CAS 操作，而是检测对象头中的线程ID是否是当前线程ID。 

> 偏向锁状态下无法获取对象的 hashcode，因为对象的 hashcode 只在**无锁状态**下存储，会直接转变成重量级锁，hashcode 存储在**MarkOop对象头**中。

## 轻量级锁

轻量级锁又称作**自旋锁**。

当有其他线程加入**锁竞争**时，偏向锁就会转为轻量级锁。

> 锁竞争：当多个线程轮流获取一个锁时，每次获取锁顺利且没有阻塞，就不存在锁竞争。只有当某个线程获取锁时发现锁已经被占用，只能等待释放，这才发生了锁竞争。

在轻量级锁下，没有抢到锁的线程会以**自旋**的方式获取锁。获取锁通过 CAS 操作修改对象头中的**锁标志位**。

# 重量级锁

当自旋操作超过**10**次时，认为锁竞争很激烈，这时候将轻量级锁转为重量级锁。当后续进程尝试获取锁时，若被占用的锁是重量级锁，则将自己挂起而不是忙等（进入阻塞状态）。

通过对象监视器 monitor 获取锁，monitor enter 抢占锁，抢占失败也会采用**自旋**的方式获取锁，自旋失败后加入等待队列，等待持有锁的进程 monitor exist 释放锁，再唤醒阻塞队列的线程。

重量级锁通过对象内部的监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。

简言之，**就是所有的控制权都交给了操作系统**，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源，导致性能低下。