# synchronized

## 作用

解决了多个线程之间并发访共享资源的同步性问题，可以保证它**修饰的方法或者代码块**只有一个线程执行。

## 使用方式

1. 修饰实例方法，给对象实例上锁，进入同步代码前要获得 **当前对象实例的锁**。
2. 修饰静态方法，也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**。因为静态成员不属于任何一个实例对象，是类成员（ _static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份_）。所以，如果一个线程 A 调用一个实例对象的非静态 `synchronized` 方法，而线程 B 需要调用这个实例对象所属类的静态 `synchronized` 方法，是允许的，不会发生互斥现象，**因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁**。
3. 修饰代码块，指定加锁对象，对给定对象/类加锁。`synchronized(this|object)` 表示进入同步代码库前要获得**给定对象的锁**。`synchronized(类.class)` 表示进入同步代码前要获得 **当前 class 的锁**

**总结：**

- `synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁。
- `synchronized` 关键字加到实例方法上是给对象实例上锁。
- 尽量不要使用 `synchronized(String a)` 因为 JVM 中，字符串常量池具有缓存功能！

## 双重校验实现单例模式

```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public  static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

## 底层原理

### 修饰同步语句块

synchorized同步语句块实现使用的是**monitorenter**和**monitorexist**指令。当执行**monitorenter**指令时，线程试图获得**对象监视器monitor**的使用权。

### 修饰方法

通过**ACC_SYNCHORIZED**标识，标明是同步方法

## 对比

### synchorized与ReentrantLock

- 两者都是**可重入锁**,即可以在获得自己内部的锁.

  比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。

  > ```java
  > class MyClass {
  >     public synchronized void method1() {
  >         method2();
  >     }
  >  
  >     public synchronized void method2() {
  >  
  >     }
  > }
  > ```
  >
  > 如果线程 A 执行了 method1，那么线程 A 就可以获得这个对象的锁，又由于 method2 也是 synchronized 方法；如果 synchonized 是不可重入锁，那么线程 A 就需要重新申请锁，又由于 A 已经获取了锁，就会造成死锁。
  >
  > 又比如在递归过程中非重入锁也会死锁。

- synchorized依赖于JVM, ReentrantLock依赖于API

- synchorized不需要用户手动释放锁,reentrantlock需要手动释放

- synchorized是不可中断锁,reentrantlock是可中断锁

  当AB都要获取锁时, A获得了锁, 如果使用 synchorized, 则B 只能等待 A 释放锁;  使用 reentrantlock, 则B在等待足够长时间后, **中断等待**, 干别的事情

- reentrantlock可指定是否是公平锁, 默认非公平. synchorized只能是**非公平锁**.

  公平锁就是先等待的线程先获得锁

- reentrantlock可使用**Condition**接口实现**选择性通知**, 即可指定唤醒哪个线程. 而 synchorized 只能随机唤醒或者唤醒全部线程

### synchrozied与volatile

- 都用于保证**多线程的安全**

- volatile修饰的变量, JVM每次都从主存上读取, 而不从工作内存上读取

  synchrozied则锁住当前变量, 同一时刻只有一个线程能够访问当前变量

- volatile仅能在变量级别, 而 synchrozied 可用在变量和方法级别

- volatile 进能够实现可见性, 无法保证原子性. 而synchrozied可以保证可见性和原子性.

