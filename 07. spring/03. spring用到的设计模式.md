# 依赖注入DI

依赖注入就是实现**控制反转IOC**的设计模式，依赖注入就是将实例变量注入对象中。

# 工厂设计模式

spring使用工厂模式可以通过 `BeanFactory` 或者 `ApplicationContext` 创建`Bean`对象。

- BeanFactory: **延迟注入**，使用到某个Bean才会创建。
- ApplicationContext: 容器启动时，**一次性创建所有Bean对象**

ApplicationContext的三个实现类

- `ClassPathXmlApplication`：把上下文文件当成类路径资源
- `FileSystemXmlApplication`：把文件系统中的xml文件载入上下文定义信息
- `XmlWebApplicationContext`：从web系统中的XML文件载入上下文定义信息

# 单例设计模式

在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。

## 好处

- 对于频繁使用的对象，可以省略对象创建的开销。
- new操作次数减少，这将减轻GC压力，增加吞吐量。

## 饿汉与懒汉

- 饿汉式：类在初始化时，创建对象。这种方式没有考虑线程安全问题，多线程下可能存在多个对象
- 懒汉式：第一次使用时才创建对象，在多线程环境下考虑线程安全问题。

```java
// 饿汉模式
public class Singleton{
    //类加载时就初始化
    private static final Singleton instance = new Singleton();
    
    private Singleton(){}

    public static Singleton getInstance(){
        return instance;
    }
}
```

```java
// 懒汉模式，使用 synchronized 实现
public class Singleton {

	// 必须声明 volatile，在多线程中instance被修改后能立即更新到主内存中
	// 如果不声明，就不是线程安全的
    private volatile static Singleton instance = null; 
    
    private Singleton (){}

    public static Singleton getSingleton() {
        if (instance == null) {                         
            synchronized (Singleton.class) {
                if (instance == null) {       
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }   
}
```

```java
// 懒汉模式，使用 reentrantlock 实现
import java.util.concurrent.locks.ReentrantLock;

public class Singleton2 {

	// 必须声明 volatile，在多线程中instance被修改后能立即更新到主内存中
	// 如果不声明，就不是线程安全的
	private volatile static Singleton2 instance = null; 

	private static ReentrantLock lock = new ReentrantLock();

	private Singleton2() {
	}

	public static Singleton2 getSingleton() {
		if (instance == null) {
			lock.lock();
			try {
				if (instance == null) {
					instance = new Singleton2();
				}
			} finally {
				lock.unlock();
			}
		}
		return instance;
	}
}
```

# 代理模式

AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，**却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来**，便于**减少系统的重复代码**，**降低模块间的耦合度**，并**有利于未来的可拓展性和可维护性**。

**Spring AOP 就是基于动态代理的**，如果要代理的对象，实现了某个接口，那么Spring AOP会使用**JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用**Cglib** ，这时候Spring AOP会使用 **Cglib** 生成一个被代理对象的子类来作为代理，如下图所示：

# 模板方法

模板方法是一种**行为设计模式**，定义了**一个操作中的算法股架，将一些步骤延迟到子类中**。

```java
public abstract class Template {
    //这是我们的模板方法
    public final void TemplateMethod(){
        PrimitiveOperation1();  
        PrimitiveOperation2();
        PrimitiveOperation3();
    }

    protected void  PrimitiveOperation1(){
        //当前类实现
    }
    
    //被子类实现的方法
    protected abstract void PrimitiveOperation2();
    protected abstract void PrimitiveOperation3();

}
public class TemplateImpl extends Template {

    @Override
    public void PrimitiveOperation2() {
        //当前类实现
    }
    
    @Override
    public void PrimitiveOperation3() {
        //当前类实现
    }
}
```

spring中的 **jdbcTemplate**、**hibernateTemplate** 等对数据库操作的类，使用的就是模板模式。

# 观察者模式

观察者模式是一种**对象行为型模式**，表示一个对象对另一个对象具有依赖关系，当一个对象改变时，这个对象所依赖的对象也会做出反应。

**Spring事件驱动模型就是观察者模式的一个应用**。

> Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。

## spring事务模型三角色

### 事件角色

`ApplicationEvent`充当事件的角色,这是一个抽象类，它继承了`java.util.EventObject`

Spring 中默认存在以下事件，他们都是对 `ApplicationContextEvent` 的实现(继承自`ApplicationContextEvent`)：

- `ContextStartedEvent`：`ApplicationContext` 启动后触发的事件;
- `ContextStoppedEvent`：`ApplicationContext` 停止后触发的事件;
- `ContextRefreshedEvent`：`ApplicationContext` 初始化或刷新完成后触发的事件;
- `ContextClosedEvent`：`ApplicationContext` 关闭后触发的事件。

### 事件监听者角色

`ApplicationListener` 充当了事件监听者角色，它是一个接口，里面只定义了一个 `onApplicationEvent（）`方法来处理`ApplicationEvent`。所以，在 Spring中我们只要实现 `ApplicationListener` 接口实现 `onApplicationEvent()` 方法即可完成监听事件

### 事件发布者角色

`ApplicationEventPublisher` 充当了事件的发布者，它也是一个接口。`ApplicationEventPublisher` 接口的`publishEvent（）`这个方法在`AbstractApplicationContext`类中被实现。实际上事件真正是通过`ApplicationEventMulticaster`来广播出去的。

## spring事件流程

1. 定义一个**事件**：实现一个继承自 **ApplicationEvent**，并且写相应的构造函数。
2. 定义一个**事件监听者**：实现 **ApplicationListener** 接口，重写 **onApplicationEvent()** 方法。
3. 使用**事件发布者**发布消息：可以通过 **ApplicationEventPublisher** 的 **publishEvent()** 方法发布消息。

# 适配器模式

适配器模式可以将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的类可以一起工作，别名为包装类（Wrapper）。

## SpringAOP适配器

我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的**增强或通知(Advice)使用到了适配器模式**，与之相关的接口是**`AdvisorAdapter` **。

Advice 常用的类型有：`BeforeAdvice`（目标方法调用前,前置通知）、`AfterAdvice`（目标方法调用后,后置通知）、`AfterReturningAdvice`(目标方法执行结束后，return之前)等等。

每个类型Advice（通知）都有**对应的拦截器:**`MethodBeforeAdviceInterceptor`、`AfterReturningAdviceAdapter`、`AfterReturningAdviceInterceptor`。

Spring预定义的通知要通过对应的适配器，适配成 `MethodInterceptor`接口(方法拦截器)类型的对象（如：`MethodBeforeAdviceInterceptor` 负责适配 `MethodBeforeAdvice`）。

## SpringMVC适配器

在Spring MVC中，`DispatcherServlet` 根据请求信息调用 `HandlerMapping`，解析请求对应的 `Handler`。解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由`HandlerAdapter` 适配器处理。`HandlerAdapter` 作为期望接口，具体的适配器实现类用于对目标类进行适配，`Controller` 作为需要适配的类。

Spring MVC 中 `Controller` 种类众多，不同的 `Controller` 通过不同的方法来请求进行处理。如果不使用适配器模式，则前端控制器`DispatcherServlet`要自行判断使用哪个`Controller`。这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。

# 装饰者模式

装饰着模式可以动态地给对象添加一些额外的属性和行为。相比于继承，装饰者模式更加灵活。

当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。

其实在 JDK 中就有很多地方用到了装饰者模式，比如 `InputStream`家族，`InputStream` 类下有 `FileInputStream` (读取文件)、`BufferedInputStream` (增加缓存,使读取文件速度大大提升)等子类都在不修改`InputStream` 代码的情况下扩展了它的功能。

Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源

# 责任链模式

使多个对象都有机会处理请求，从而避免了请求发送者和接受者的耦合关系。将这些对象连成一条链，并且沿着这条链传递该请求，直到有对象处理它为止。

## 优点

- 解耦，请求发送方和接收方解耦，并不会对处理逻辑进行强绑定

- 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接

- 在给对象分派职责时，责任链可以给我们更多的灵活性，可以在运行时对该链进行动态的增删改，改变处理一个请求的职责

## 应用

- Netty 中的 Pipeline 和 ChannelHandler 通过责任链设计模式来组织代码逻辑
- Spring Security 使用责任链模式，可以动态地添加或删除责任（处理 request 请求）
- Spring AOP 通过责任链模式来管理 Advisor
- Dubbo Filter 过滤器链也是用了责任链模式（链表），可以对方法调用做一些过滤处理，譬如超时(TimeoutFilter)，异常(ExceptionFilter)，Token(TokenFilter)等
- Mybatis 中的 Plugin 机制使用了责任链模式，配置各种官方或者自定义的 Plugin，与 Filter 类似，可以在执行 Sql 语句的时候做一些操作

## 实现

在 Spring 中主要使用了三个注解 `@Component`, `@Order`, `@PostConstruct`

- `@Component`：将我们的子类交给Spring管理
- `@Order`：定义我们链条的顺序
- `@PostConstruct`：程序启动时将我们链条组合起来

1. 定义责任链的抽象类

   ```java
   public abstract class PrintChainPattern {
   	private PrintChainPattern next;
     public final void print() {
       String message = getMessage();
       log.info("{} : {}",message,message);
       if (getNext()!=null){
         getNext().print();
       }
     }
     public abstract String getMessage();
   }
   ```

2. 定义实现类，使用 @Order() 注解，注解中的数字依次递增

   ```java
   @Order(1)
   @Component
   public class OnePrintChainPattern extends PrintChainPattern{
     @Override
     public String getMessage() {
       return "one";
     }
   }
   ```

3. Spring 组装链表，使用 @PostConstruct

   ```java
   @Configuration
   public class InitPrintChainPattern {
     @Autowired
     private List<PrintChainPattern> printChainPatterns;
     @PostConstruct
     private void initPrintChainPattern(){
       Collections.sort(printChainPatterns, AnnotationAwareOrderComparator.INSTANCE);
       int size = printChainPatterns.size();
       for (int i = 0; i < size; i++) {
         if (i == size-1){
           printChainPatterns.get(i).setNext(null);
         } else {
           printChainPatterns.get(i).setNext(printChainPatterns.get(i+1));
         }
       }}
     public void print(int index){
       printChainPatterns.get(index-1).print();
     }
   }
   ```

   这里我们可以看到在`@PostConstruct`方法中我们做了两件事

   1. 将`List`中按照`@Order`注解的数字进行排序
   2. 依次设置每个节点的next值

4. 