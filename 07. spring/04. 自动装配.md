# springboot 自动装配

在 springboot 之前的 spring 使用某一个功能或者引入第三方依赖时，需要 xml 或者 java 进行显示配置。但是在 springboot 中，只需要添加相关依赖，无需配置，通过调用 SpringApplication.run() 方法即可。

自动装配即拆箱即用，通过注解或者简单的配置就能在 springboot 中实现某功能。

# 如何实现

在 springboot 启动类 `...Application` 中定义了注解 **`@SpringBootApplication`** 

其中 `@SpringBootApplication` 中的核心注解为:

`@Configuration`、`@EnableAutoConfiguration`、`@ComponentScan`

其中，三个注解的作用为：

- `@EnableAutoConfiguration`：启用 SpringBoot 的自动配置机制
- `@Configuration`：允许在上下文中注册额外的 bean 或导入配置类
- `@ComponentScan`：扫描被 `@Component` 注册的 bean，默认扫描**启动类**包下所有的类

其中，`@EnableAutoConfiguration` 是实现自动装配的重要注解

# @EnableAutoConfiguration

`@EnableAutoConfiguration` 只是简单的注解，自动装配的核心功能的实现是通过导入`AutoConfigurationImportSelector` 类。

```java
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration{}
```

## AutoConfigurationImportSelector

这个 AutoCOnfigurationImportSelector 可以加在自动装配类

> 首先该类实现了 `DeferredImportSelector` 接口，这个接口继承了 `ImportSelector`。
>
> `ImportSelector` 主要是为了导入 `@Configuration` 配置项，而`DeferredImportSelector` 是**延期导入**，即当所有的 `@Configuration` 都处理过后才会执行。

其中 `AutoConfigurationImportSelector` 类实现了 `ImportSelector` 接口中的 `selectImports` 方法，该方法主要用于**获取所有符合条件的类的全限定名，这些类需要被加载到 IOC 中**。

该方法首先判断是否进行自动装配，之后调用`getAudoConfigurationEntry`，这个方法主要负责加载自动装配类。

1. 首先判断是否打开自动装配，默认`spring.boot.enableautoconfiguration=true`，可在 `application.properties` 或 `application.yml` 中设置

2. 调用 `getAttributes` 方法获取`EnableAutoConfiguration`注解中的 `exclude` 和 `excludeName`。

3. 调用 `getCandidateConfigurations` 获取自动装配的所有配置类，读取`META-INF/spring.factories`

4. 调用 `filter` 方法来进行筛选，只有满足 `@ConditionOnXX` 里的条件才会加载

   > - `@ConditionalOnBean`：当容器里有指定 Bean 的条件下
   > - `@ConditionalOnClass`：当类路径下有指定类的条件下

## 实现代码

```java
public String[] selectImports(AnnotationMetadata annotationMetadata) {
// 判断自动装配开关是否打开
    if (!isEnabled(annotationMetadata)) {
        return NO_IMPORTS;
    }
    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);
    return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
}
```

```java
protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
   if (!isEnabled(annotationMetadata)) {
      return EMPTY_ENTRY;
   }
   AnnotationAttributes attributes = getAttributes(annotationMetadata);
   // 获取候选的配置类
   List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);
  // 移除重复的配置 
  configurations = removeDuplicates(configurations);
  // 获取到要排除的配置 
  Set<String> exclusions = getExclusions(annotationMetadata, attributes); 
  checkExcludedClasses(configurations, exclusions);
  // 移除所有要排除的配置
   configurations.removeAll(exclusions);
  // 过滤掉不具备注入条件的配置类，通过Conditional注解
  configurations = getConfigurationClassFilter().filter(configurations);
  // 通知自动配置相关的监听器
   fireAutoConfigurationImportEvents(configurations, exclusions);
   return new AutoConfigurationEntry(configurations, exclusions);
}
```



