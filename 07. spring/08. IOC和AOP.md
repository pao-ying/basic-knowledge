# IOC

**IOC是指在程序开发过程中，对象实例的创建不再由调用者管理，而是由Spring容器创建，Spring容器会负责控制程序之间的关系，而不是由代码直接控制，因此，控制权由程序代码转移到了Spring容器，控制权发生了反转，即控制反转。** **Spring IOC提供了两种IOC容器，分别是BeanFactory和ApplicationContext。**

> DI，即依赖注入，是最常见以及最合理的IOC实现方式。组件之间的依赖关系有容器在运行期间决定，也就是由容器动态的将某个依赖关系注入到组件中。DI 的目的并不是提供更多功能，而是提高组件的可重用性。

## BeanFactory

BeanFactory是基础的IOC容器，是一个接口，提供了完整的IOC服务，BeanFactory是一个管理Bean的工厂，他主要负责初始化各种bean，并调用它们的生命周期方法。

BeanFactory接口有多个实现类，最常见的是**XmlBeanFactory**，它根据Xml配置文件中的定义装配Bean。 **创建XmlBeanFactory对象，传入xml文件**

```java
BeanFactory beanFactory = new XmlBeanFactory(newFileSystemResource("D://applicationContext.xml"));
```

## ApplicationContext

**ApplicationContext是BeanFactory的字接口，也被称为应用上下文，不仅提供了BeanFactory的所有功能，还添加了对国际化、资源访问、事件传播等方面的支持。**

ApplicationContext提供了两个实现类

- **ClassPathXmlApplicationContext** 该类从类路径ClassPath中寻找制定的xml文件

  ```java
  // configLocation参数用来指定Spring配置文件的名称和位置
  ApplicationContext applicationContext = new ClassPathXmlApplicationContext(String configLocation);
  ```

- **FileSystemXmlApplicationContext** 该类从指定的文件系统路径中寻找指定的xml文件

  ```java
  * ApplicationContext applicationContext = new FileSystemXmlApplicationContext(String configLocation);
  ```

## BeanFactory 和 ApplicationContext 区别

如果Bean的某一个属性没有注入，则使用BeanFactory加载后，在第一次调用getBean方法时会抛出异常，而ApplicationContext会在初始化时检查，有利于检查所依赖的属性是否注入。

## 好处

1. 对象之间的**耦合度**降低
2. 资源更容易管理

## 原理

IOC 的原理就是通过**反射**，在 **applicationContext.xml** 文件中查找 <bean id='' class=''></bean> 标签，对 `class` 中的全限定类名进行实例化，同时以 `id` 为键值放到一个 `Map` 数据结构中。

# AOP

AOP，即**面向切面编程**。

主要是用来解决**业务代码**中的**横切逻辑代码**。

## 横切逻辑代码

横切逻辑代码存在的问题：

- 代码重复问题
- 横切逻辑代码和业务代码混杂在一起

横切逻辑代码适用场景：**事务控制、校验权限、日志**。

## AOP解决的问题

- 降低耦合度
- 使系统易扩展
- 提高代码的复用性

## 为什么叫面向切面编程

**切** ：指的是横切逻辑，原有业务逻辑代码不动，只能操作横切逻辑代码，所以面向横切逻辑

**面** ：横切逻辑代码往往要影响的是很多个方法，每个方法如同一个点，多个点构成一个面。这里有一个面的概念

## 动态代理

如果要代理的对象实现了某个接口，spring就会使用**JDK Proxy**。

> JDK Proxy 关注 InvocationHandler 和 Proxy。自定义类实现 InvocationHandler，并重写 invoke() 方法，在方法内进行增强并调用原方法。再调用 Proxy.newProxyInstance() 生成代理对象。

如果没有实现了接口的对象，spring就会使用**Cglib**。

> Cglib 关注 MethodInterceptor 和 Enhancer。自定义实现 MethodInterceptor，并重写 intercept() 方法，在方法内进行增强并调用原方法。再调用 Enhancer.create() 生成代理对象。

## SpringAOP和AspectAOP

- Spring AOP 是**运行时增强**， Aspect Aop 是**编译时增强**。
- Spring AOp 是基于代理，Aspect Aop 是基于**字节码操作**