# 事务管理

## 编程式事务管理

使用 `transactionTemplate` 或者 `transactionManager` 手动管理事务。

```java
@Autowired
private TransactionTemplate transactionTemplate;
public void testTransaction() {

        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {

                try {

                    // ....  业务代码
                } catch (Exception e){
                    //回滚
                    transactionStatus.setRollbackOnly();
                }

            }
        });
}
```

```java
@Autowired
private PlatformTransactionManager transactionManager;

public void testTransaction() {

  TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
          try {
               // ....  业务代码
              transactionManager.commit(status);
          } catch (Exception e) {
              transactionManager.rollback(status);
          }
}
```

## 声明式事务管理

基于AOP，即`@transaction` 注解实现

```java
@Transactional(propagation=propagation.PROPAGATION_REQUIRED)
public void aMethod {
  //do something
  B b = new B();
  C c = new C();
  b.bMethod();
  c.cMethod();
}
```

# 事务管理接口

- `PlatformTransactionManager` 即事务管理器，spring事务的核心
- `TransactionDefinition` 即事务定义信息如事务隔离级别、传播行为、超时、只读、回滚规则等
- `TransactionStatus` 即事务运行状态

## PlatformTransactionManager

事务管理接口。

通过这个接口，spring为各个平台如JDBC，Hibernate，JPA提供了对应的事务管理器，具体的实现就是各个平台的事情了。

```java
package org.springframework.transaction;

import org.springframework.lang.Nullable;

public interface PlatformTransactionManager {
    //获得事务
    TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException;
    //提交事务
    void commit(TransactionStatus var1) throws TransactionException;
    //回滚事务
    void rollback(TransactionStatus var1) throws TransactionException;
}
```

## TransactionDefinition

事务的属性包括五个方面

- 隔离级别
- 传播行为
- 回滚规则
- 是否只读
- 事务超时

```java
package org.springframework.transaction;

import org.springframework.lang.Nullable;

public interface TransactionDefinition {
    int PROPAGATION_REQUIRED = 0;
    int PROPAGATION_SUPPORTS = 1;
    int PROPAGATION_MANDATORY = 2;
    int PROPAGATION_REQUIRES_NEW = 3;
    int PROPAGATION_NOT_SUPPORTED = 4;
    int PROPAGATION_NEVER = 5;
    int PROPAGATION_NESTED = 6;
    int ISOLATION_DEFAULT = -1;
    int ISOLATION_READ_UNCOMMITTED = 1;
    int ISOLATION_READ_COMMITTED = 2;
    int ISOLATION_REPEATABLE_READ = 4;
    int ISOLATION_SERIALIZABLE = 8;
    int TIMEOUT_DEFAULT = -1;
    // 返回事务的传播行为，默认值为 REQUIRED。
    int getPropagationBehavior();
    //返回事务的隔离级别，默认值是 DEFAULT
    int getIsolationLevel();
    // 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。
    int getTimeout();
    // 返回是否为只读事务，默认值为 false
    boolean isReadOnly();

    @Nullable
    String getName();
}
```

## TransactionStatus

用来记录事务的状态

```java
public interface TransactionStatus{
    boolean isNewTransaction(); // 是否是新的事务
    boolean hasSavepoint(); // 是否有恢复点
    void setRollbackOnly();  // 设置为只回滚
    boolean isRollbackOnly(); // 是否为只回滚
    boolean isCompleted; // 是否已完成
}
```

# 事务属性

## 事务传播行为

**事务传播行为用来解决业务层方法之间互相调用的事务问题**。

### propagation_require

即如果当前存在事务，则加入该事务；

如果当前没有事务，则创建一个事务，且相互独立，不干扰。

- 外部方法没有开启事务，则内部被 `propagation.require` 修饰的方法会开启自己的事务，且相互独立，互不干扰。
- 外部方法开启了事务并被 `propagation.require` 修饰，则内部被 `propagation.require`修饰的方法会和外部方法共用同一事务。

> 即外部回滚，内部也要回滚。内部回滚，外部也要回滚。

### propagation_require_new

创建一个新的事务，如果当前存在事务，则把当前事务挂起，且相互独立，互不干扰。相当于内部执行完了就执行完了。

> 即外部回滚，内部不回滚。内部回滚，外部要回滚。

### propagation_nested

如果当前存在事务，则创建一个事务作为当前事务的嵌套事务，即外事务回滚，子事务也会回滚；子事务回滚，外事务不会回滚。

当不存在事务时，会创建一个事务。

> 即外部回滚，内部回滚。内部回滚，外部不回滚。

### progation_mandatory

如果存在事务，则加入该事务；

如果不存在，就抛出异常。

### progation_supports

如果存在事务就加入该事务。

没有事务，就以非事务的方式进行。

### progation_not_supports

如果存在事务，把当前事务挂起，以非事务方式进行。

没有事务，则以非事务的方式进行。

### progation_never

如果存在事务，抛出异常。

没有事务，以非事务的方式进行。

## 事务隔离级别

### isolation_default

数据库默认隔离级别，可重复读

### isolation_read_uncommited

读未提交

### isolation_read_commited

读已提交

### isolation_repeatable_read

可重复读

### isolation_serializable

序列化

## 事务超时属性

即一个事务允许执行的最长时间，超过该时间就会回滚。

## 事务只读属性

只读事务不涉及数据修改，会提供优化手段，适用于多条数据库查询操作的方法中。

## 事务回滚规则

规则定义了哪些异常会导致事务回滚。默认情况下是**RuntimeException**和**Error**才会回滚, 遇到受检异常不会回滚。