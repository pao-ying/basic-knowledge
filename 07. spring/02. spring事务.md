# 事务管理

## 编程式事务管理

使用 `transactionTemplate` 或者 `PlatformTransactionManager` 手动管理事务。

## 声明式事务管理

基于AOP，即`@transaction` 注解实现。

# 事务管理接口

## **PlatformTransactionManager**

事务管理接口，spring事务的核心，声明了三个方法

- getTransaction(TransactionDefinition definition) 获得事务

- commit(TransactionStatus status) 提交事务

- Rollback(TransactionStatus status) 回滚事务

通过这个接口，spring为各个平台如JDBC，Hibernate，JPA提供了对应的事务管理器，具体的实现就是各个平台的事情了。

## TransactionDefinition

```java
public interface TransactionDefinition {
    // 返回事务的传播行为
    int getPropagationBehavior(); 
    // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据
    int getIsolationLevel(); 
    // 返回事务必须在多少秒内完成
    //返回事务的名字
    String getName()；
    int getTimeout();  
    // 返回是否优化为只读事务。
    boolean isReadOnly();
} 

```

### 隔离级别

- **ISOLATION_DEFAULT**：后端默认采用的隔离级别。Mysql 为 可重复读级别，Oracle 为 读已提交级别。
- **ISOLATION_READ_UNCOMMITTED**：读未提交。
- **ISOLATION_READ_COMMITTED**：读已提交
- **ISOLATION_REPEATABLE_READ**：可重复读
- **ISOLATION_SERIALIZABLE**：序列化

### 事务传播行为

#### 支持当前事务情况：

- **PROPAGATION_REQUIRED**
  - 当前存在事务就加入当前事务，内部方法或者外部方法属于同一事务，只要一个方法回滚，整个事务都会回滚。
  - 当前不存在事务，则开启自己的新事务，开启的事务不会受其他事务影响。
- **PROPAGATION_SUPPORTS**：如果当前存在事务就加入当前事务；如果当前没有事务，则以非事务的方式继续运行。
- **PROPAGATION_MANDATORY**：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）

#### 不支持当前事务情况

- **PROPAGATION_REQUIRES_NEW**
  - 当前存在事务，内部方法依然会开启独立事务，且与外部事务独立。（如果内部事务抛出异常且没有 catch，外部事务会感知并且回滚）
  - 当前不存在事务，则开启自己的事务，开启的事务不会受其他事务影响。
- **PROPAGATION_NOT_SUPPORTED**：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
- **PROPAGATION_NEVER**：以非事务方式运行，如果当前存在事务，则抛出异常。

**请他情况**

- **PROPAGATION_NESTED**
  - 当前存在事务，内部事务为外部事务的子事务，外部事务回滚，内部事务会回滚；内部事务回滚，不会影响外部事务和其他事务。
  - 当前不存在事务，等价于 PROPAGATION_REQUIRED，即开启自己的事务，且开启的事务相互独立。

#### required 与 requires_new 与 nested 异同

nested 和 required 修饰的内部方法都属于外部事务，如果外部方法抛出异常，那么内部事务都会回滚。但是 required 是加入外部事务，即内部事务**回滚**，外部事务也会回滚；而 nested 是嵌套事务，即内部事务回滚，不会影响外部事务和内部其他事务。

nested 和 requires_new 都可以做到内部事务回滚不影响外部事务。但是因为 nested 是嵌套事务，外部事务回滚之后，作为外部事务的子事务也会回滚。而 requires_new 是通过开启新的事务实现的，所以内部事务和外部事务是两个事务，外部事务回滚不会影响内部事务。

### 事务超时属性

即一个事务允许执行的最长时间，超过该时间就会回滚。

### 事务只读属性

对**事务性资源**进行只读操作或者是读写操作。所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。**如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。**

### 事务回滚规则

规则定义了哪些异常会导致事务回滚。默认情况下是**RuntimeException**和**Error**才会回滚, **遇到受检异常不会回滚。**

## TransactionStatus

TransactionStatus接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息.

```java
public interface TransactionStatus{
    boolean isNewTransaction(); // 是否是新的事物
    boolean hasSavepoint(); // 是否有恢复点
    void setRollbackOnly();  // 设置为只回滚
    boolean isRollbackOnly(); // 是否为只回滚
    boolean isCompleted; // 是否已完成
} 

```

