# 红黑树

红黑树，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉查找树(BST)

## 为什么有平衡树还要红黑树

### 二叉查找树 BST

二叉查找树就是左子节点值比父节点值小，父节点值小于右子节点值。正常情况下查找效率为 **O(log n)**.

但是当二叉树**退化为链表**时，查询效率就变为**O(n)**。

### 平衡二叉树 AVL

平衡二叉树就是为了解决二叉查找树退化为链表问题而产生的。他的特点是每个结点的左子树高度和右子树高度相差至多等于1.

### 红黑树 RB- TREE

为什么有了平衡二叉树还需要红黑树？因为平衡树要求左子树高度和右子树高度相差1，要求太过于严格，对于频繁插入删除的时候，几乎都会破坏这个规则。

红黑树只要求部分达到平衡，但是提出了**为节点增加颜色**，红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。

就插入节点导致树失衡的情况，AVL和RB-Tree都是最多两次树旋转来实现复衡rebalance，旋转的量级是O(1)
删除节点导致失衡，AVL需要维护从被删除节点到根节点root这条路径上所有节点的平衡，旋转的量级为O(logN)，而RB-Tree最多只需要旋转3次实现复衡，只需O(1)，所以说RB-Tree删除节点的rebalance的效率更高，开销更小！

## 性质

- 每个节点要么是黑色，要么是红色。

- 根节点是黑色

- 每个叶子节点（NIL）是黑色。

- 每个红色结点的两个子结点一定都是黑色。(不能有两个连续的红色节点）

  如果不满足，则需要进行自平衡操作

- 任意一结点到每个叶子结点的路径都包含数量相同的黑结点。（保证这棵树尽量是平衡的。）

## 红黑树自平衡操作

**变色与旋转，先变色，再旋转**

假设我们插入的新节点为 X

1. 将新插入的节点标记为红色

2. 如果 X 是根结点(root)，则标记为黑色

3. 如果 X 的 parent 不是黑色，同时 X 也不是 root:

   - 如果 X 的 uncle (叔叔) 是红色

     1. 将 parent 和 uncle 标记为黑色

     2. 将 grand parent (祖父) 标记为红色

     3. 让 X 节点的颜色与 X 祖父的颜色相同，同时让 X 祖父为 X 节点，然后重复步骤 2、3

   - 如果 X 的 uncle 是黑色，则使用旋转，X 为当前节点，P 为 parent,  G 为 grandparent

     - 左左情况( p 是 g 的左节点，x 是 p 的左节点)

       将 g 节点右旋。同时P节点变黑色，x g 变红色

       ![img](/Users/bytedance/GithubProject/basic-knowledge/img/v2-9e139a0f8b4a5e00ca8e643e2130403c_b.png)

     - 左右情况 (p 是 g 的左节点，x 是 p 的右节点)

       将 p 左旋，再将 g 右旋。同时 x 变黑色，p g 变红色

       ![img](/Users/bytedance/GithubProject/basic-knowledge/img/v2-3fb33fbb3a42e34ed8a058a047a44cc3_b.png)

     - 右右情况(p 是 g 的右节点，x 是 p 的右节点)

       将 g 节点左旋，p 节点变黑色，x g 变红色

       ![img](/Users/bytedance/GithubProject/basic-knowledge/img/v2-62a42ada09cb4547191aa4b9051c7c23_b.png)			

     - 右左情况(p 是 g 的右节点，x 是 p 的左节点)

       将 p 节点右旋，再将 g 节点左旋。x 变黑色，pg 变红色

       ![img](/Users/bytedance/GithubProject/basic-knowledge/img/v2-210d1400ea1b098dfe1582589a6064c3_b.png)				

