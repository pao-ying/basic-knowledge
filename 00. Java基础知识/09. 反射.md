# 定义

Java 的**反射机制**是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。

# class对象

首先有一个概念叫做**RTT**，即运行时类型识别，其作用是在运行时识别一个对象的类型和类的信息。Java实现RTT的方法有两种，第一种就是在编译期就已经知道了所有类型。另一种就是反射，它允许我们在运行时发现和使用类的信息。

而每个类都有一个 Class 对象，每当编译一个新类就会产生一个 Class 对象，该 Class 对象保存了 Student 类相关的类型信息。所以 Class 对象的作用就是运行时提供或获取某个对象的类型信息。

# 反射基本使用

## 获取Class类对象

- 使用**Class.forName**

  ```java
  Class class1 = Class.forName("com.example.Apple");
  ```

- 使用类.class 方法

  ```java
  Class class2 = Apple.class;
  ```

- 使用实例对象的 getClass() 方法

  ```java
  Apple apple = new Apple();
  Class class3 = apple.getClass();
  ```

测试时，调用`class.getName()` 查看结果是否相同。

## 反射创造对象

- 通过 class 的 newInstance() 方法

  ```java
  Class class = Class.forName("Apple");
  Apple apple = (Apple) class.newInstance();
  ```

- 通过 Constructor 的 newInstance() 方法

  ```java
  Constructor constructor = class.getConstructor();
  Apple apple = (Apple) constructor.newInstance();
  ```

## 反射获取类的构造器

- getConstructors() 和 getDeclaredConstrucotors() 获取所有构造器
- getConstructor(Class[] parameterTypes) 和 getDeclaredConstructor(Class[] parameterTypes) 获取指定参数类型的构造器

是否加 Declared 的区别就是，不加Declared只返回 public，加了Declared返回所有类型的构造器。

```java
Constructor[] constructors = class.getDeclaredConstructors();
for (int i = 0; i < constructors.length; i++) {
  System.out.println(constructors[i]);
}
```

## 反射获取类的成员变量

- getFields 获得类的 public 类型属性，getDeclareField() 获得类的所有属性
- getField(String name) 根据变量名获得具有public属性的成员变量，getDeclaredField(String name) 根据变量名，返回一个成员变量

```java
Field price = class.getField("price");
System.out.println(price);//com.example.Apple.price
```

## 反射获取类的方法

- getMethods() 获取类的 public 类型的方法，getDeclaredMethods() 获取类的所有方法

- getMethod(String name, Class[] parameterTypes) 获得类的特定方法

```java
Method[] methods = class1.getMethods();
for (int i = 0; i < methods.length; i++) {
  System.out.println(methods[i]);// public String com.example.Apple.getName()
}
```

# 实现原理

Method.invoke() 方法中：

首先会校验权限，之后调用**接口 MethodAccessor的invoke()**方法，MethodAccessor接口有三个实现类 DelegatingMethodAccessorImpl, MethodAccessorImpl, NativeMethodAccessorImpl。

具体使用哪个实现类通过调用 **acquireMethodAccessors**决定的，在该方法内部，会调用 **reflectionFactory 的 newMethodAccessor()**方法。

在 newMethodAccessor() 方法中，可以看到返回的是 **DelegatingMethodAccessorImpl 的 invoke()** 方法，再进入 invoke() 方法，发现其实返回的是 **MethodAccessorImpl 的 invoke** 方法，而该方法，是用他的子类**NativeMethodAccessorImpl** 重写，这时候返回的是本地方法 invoke0。

所以 method.invoke() 方法，是由本地方法 invoke0() 决定的。

# 存在的问题

## 性能问题

java反射的性能并不好，原因主要是编译器可以对正常的实例化做优化，但是没法对反射相关的代码做优化。

- **Method#invoke 方法会对参数做封装和解封操作**

  invoke 方法的参数是 Object[] 类型，也就是说，如果方法参数是简单类型的话，需要在此转化成 Object 类型，例如 long ,在 javac compile 的时候 用了Long.valueOf() 转型，也就大量了生成了Long 的 Object, 同时 传入的参数是Object[]数值,那还需要额外封装object数组。

- **需要检查方法可见性**

  反射时每次调用都必须检查方法的可见性（在 Method.invoke 里）

- **需要校验参数**

  反射时也必须检查每个实际参数与形式参数的类型匹配性

- **JIT 无法优化**

  因为反射涉及到动态加载的类型，所以无法进行优化。

## 安全问题

我们知道单例模式的设计过程中，会强调**将构造器设计为私有**，因为这样可以防止从外部构造对象。但是反射可以获取类中的域、方法、构造器，**修改访问权限**。所以这样并不一定是安全的。

