# 用户/内核空间

为了保证操作系统的安全性，一个进程的地址空间分为 **用户空间** 和 **内核空间**。

我们平常运行的应用程序都是运行在用户空间，只有内核空间才可以进行系统态级别的资源相关操作，比如文件管理、进程通信、内存管理等。

并且用户空间不能直接访问内核空间，如用户进程要执行 IO 操作，必须通过**系统调用**来间接请求操作系统。

应用程序发起 IO 调用时，会经历两个步骤：

1. 内核等待 IO 设备准备好数据。
2. 内核将数据从内核空间拷贝到用户空间。

# IO调用和IO执行

- IO调用: 进程向内核发起系统调用
- IO执行: 
  - 准备阶段: 内核等待IO设备准备好数据
  - 拷贝阶段: 将数据从内核缓冲区拷贝到用户缓冲区(线程缓冲区)中

# 阻塞/非阻塞-异步/同步

- 阻塞/非阻塞，即线程在发起调用后，是否会阻塞等待 IO 执行完成，如果会等待，则线程变为阻塞状态，即阻塞IO；若不等待，即继续运行状态，即非阻塞IO
- 异步/同步，即线程在发起调用后，是否会继续执行，如果会继续执行，则为异步IO，如果会等待调用完成后继续执行，则为同步IO

# 阻塞IO(BIO)

进程从发起IO调用一直到IO执行结束返回结果之前都处于等待状态.

> BIO 中，应用程序发起 read 调用后，会一直阻塞，直到内核将数据拷贝到用户空间。

# 非阻塞IO(NIO)

NIO：Non-blocking/New I/O

## 同步非阻塞

进程从发起IO调用一直到IO执行**准备好数据**这段期间, 不会处于等待状态, 采用**轮询**操作. 而数据就绪后的拷贝操作仍是处于等待状态.

> NIO 中，应用程序会**一直发起 read 调用**，这段时间是不阻塞的，当数据从内核空间拷贝到用户空间时，这段时间是阻塞的。

## IO 多路复用

线程发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好之后，用户线程发起 read 调用。read 调用过程即数据从内核空间到用户空间是阻塞的。

### 机制

该机制是通过 **多路复用器** 实现的。

多路复用器可以让单个线程监视多个客户端(socket)、文件连接，当客户端(socket)、文件数据准备就绪后，通知目标线程发起 read 调用。

> 文件描述符 (File descriptor) 用于表述指向文件的引用的抽象化概念。

- select 机制

  select 机制中提供一个 **fd_set** 的数据结构，实际是 Long 类型的数组，存储的是文件描述符。当调用 select() 时，**内核**根据 IO 状态来修改 fd_set 的内容，由此来通知执行了 select() 的进程哪个 **socket 或 文件** 可读。

  问题：

  - 每次调用 select() 都需要将 fd_set 从**用户态拷贝到内核态**。
  - 同时遍历 fd_set
  - 为了减少拷贝的性能损坏，内核对 fd_set 大小做了限制。

- poll 机制

  poll 机制与 select 类似，只是解决了大小限制问题。

- epoll 机制

  epoll 机制是基于**事件驱动**的IO方式，**解决了大小限制**。

  epoll 提供的函数

  ```c
  int epoll_create(int size);
  int epoll_ctl(...);
  int epoll_wait(...);
  ```

  - epoll_create 创建**epoll 句柄**，函数声明要监听的文件描述符数量
  - epoll_ctl 函数在**内核**中注册要监听的文件描述符，只需一次用户态到内核态拷贝，可以**解决 select/poll 每次调用都需要将 fd_set 从用户态拷贝到内核态的问题**。
  - epoll_wait() 函数等待事件的就绪，即**事件驱动**，可以**解决需要遍历 fd_set 的问题**。

![img](..\img\0f483f2437ce4ecdb180134270a00144~tplv-k3u1fbpfcp-watermark.image)

# 异步IO(AIO)

进程发起IO调用后, 无需等待, 操作系统会返回数据是否拷贝成功的标识.