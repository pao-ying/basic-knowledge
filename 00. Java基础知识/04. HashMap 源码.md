# 底层数据结构

## JDK 1.8之前

使用 **数组+链表**，其中 `hash` 函数扰动了 **4**次。

使用**拉链法**，即创建一个数组，数组的每一格就是一个链表。若遇到哈希冲突，将冲突的值加到链表中去。

## JDK 1.8之后

使用 **数组+链表/红黑树**，其中 `hash` 函数扰动了**1** 次

```java
(h = key.hashCode()) ^ (h >>> 16)
```

当链表长度大于**8**时，调用**treeifyBin()**，只有当数组长度是否大于等于**64**，执行转换成红黑树，否则只是执行 `resize()` 对数组进行扩容。

### 类的属性

- **loadFactor** 加载因子

  控制数组存放的疏密程度。越趋近于1，则链表长度越长。

  > loadFactor 太大导致查找元素效率低，太小数组的利用率低。默认是 0.75f

- **threshold** 很亮标准

  threshold = capacity * loadFactor，当 Size >= threshold 的时候，考虑对数组扩增。

### put

1. 查看 Node 数组是否为空，若为空则进行**扩容**
2. 定位 Node，Node不存在，则在对应位置直接插入
3. 不为空，则遍历链表或者红黑树，若为链表，则采用**尾插法**插入。
4. 插入后，如果链表长度大于8，且数组长度大于等于64，则将链表转为红黑树。

### 扩容机制

调用 resize()

1. 判断容量是否超过最大值，超过就不再扩充，

   如果没有超过，就扩充为原来的**2倍**。

2. 再计算新的 **resize** 上限

3. 遍历 hash 表的所有元素，重新分配位置。

# 为什么有平衡树还要红黑树

# 二叉查找树

二叉查找树就是左子节点值比父节点值小，父节点值小于右子节点值。正常情况下查找效率为 **O(log n)**.

但是当二叉树**退化为链表**时，查询效率就变为**O(n)**。

## 平衡二叉树

平衡二叉树就是为了解决二叉查找树退化为链表问题而产生的。他的特点是每个结点的左子树高度和右子树高度相差至多等于1.

## 红黑树

为什么有了平衡二叉树还需要红黑树？因为平衡树要求左子树高度和右子树高度相差1，要求太过于严格，对于频繁插入删除的时候，几乎都会破坏这个规则，进而需要使用**左旋/右旋**来进行调整

# hashMap的hash函数

## 为什么hashMap的数组长度为2的整数幂

由于hash值是一个int类型的值, 大部分情况下hashMap是不会有这么长的, 所以在有限的长度内, 取hash值的低几位是比较理想的**散列方式**.

而任何2的整数幂, 再减一的二进制都为1. 所以让hash值**&**上**n-1**后就是低位的hash值，在使用低位的 hash 值作为数组的索引。

```
    00100100 10100101 11000100 00100101    // Hash 值 
&   00000000 00000000 00000000 00001111    // 16 - 1 = 15
----------------------------------
    00000000 00000000 00000000 00000101    // 高位全部归零，只保留末四位。
```

## hash算法(扰动函数)

所以我们想要后几位足够散列, 才能减少碰撞次数. 而如果只是取后几位的话, 则高位不同, 但是低位相同的 hash 值就很容易碰撞了. 所以采取的方式就是将 hash 值的高 16 位与低 16 位取异或运算, 得到一个更加散列的低 16 位的 hash 值.

```
00000000 00000000 00000000 00000101 // H1
00000000 00000000 00000000 00000000 // H1 >>> 16
00000000 00000000 00000000 00000101 // hash = H1 ^ (H1 >>> 16) = 5

00000000 11111111 00000000 00000101 // H2
00000000 00000000 00000000 11111111 // H2 >>> 16
00000000 00000000 00000000 11111010 // hash = H2 ^ (H2 >>> 16) = 250

```

