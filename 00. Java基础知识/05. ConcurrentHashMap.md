# 1.7

ConcurrentHashMap 由一个 **Segment 数组**和多个 **HashEntry 数组**组成。

![img](..\img\format,png1)

目的就是**锁分离**，仅仅对**segment**进行加锁，降低锁的粒度。

## put

1. 定位 segment 位置，定位不到就初始化 segment。

   > 初始化 segment 主要是 创建 HashEntry 数组，并使用该 HashEntry 初始化 Segment，然后**自旋检查 HashEntry 数组是否为空和 CAS 赋值 Segment**，目的是确保只有一个线程进行了初始化。

2. 因为**Segment 继承了 ReentrantLock**，所以 tryLock() 获取锁，获取不到就使用 **scanAndLockForPut** 方法继续获取锁。

   > scanAdnLockForPut 主要操作就是 **不断自旋获取锁**，当自选次数超过指定次数后，使用 **lock()** 阻塞获取锁。

3. **哈希映射**，计算 HashEntry 数组的索引位置，获取对应位置的 HashEntry。然后对其遍历，因为 HashEntry 的项是一个链表。

4. 遍历时如果遍历到了对应 key，则替换值；如果没有遍历到，则头插法插入，或者进行扩容再插入。

## 扩容 rehash

**扩容只会是原来的两倍**

1. 计算新的容量(两倍)与阈值(threshold)，并创建新的 HasnEntry 数组
2. 对老数组的每个元素进行遍历，再对每个元素即链表进行遍历，重新计算 Hash 值插入新的 HashEntry 数组中，对于 hash 冲突的值采用头插法插入 HashEntry。

## get

**两次 Hash 映射**，但是相对于 put 操作，少了加锁过程。

# 1.8

ConcurrentHashMap 是**Node 数组(数组桶)+链表/红黑树**，并发控制使用**Synchronized关键字和CAS操作**。

## 哈希桶Table初始化

初始化 Table 是在进行 put 操作中进行的，若发现 table 还没有被初始化，就会调用方法 initTable 来进行初始化。

sizeCtl 是一个**用于同步多个线程的共享变量**，采用**自旋检查数组桶是否为空 和 CAS 操作 sizeCtl**。

- -1 表示正在初始化
- -N 表示有 N - 1 个线程正在进行扩容操作
- 若 table 未初始化，表示 table 初始化需要的大小
- 若 table 初始化，表示 table 的容量，默认 table 初试大小的 0.75

当发现sizeCtl不再小于0的时候，就会通过调用方法compareAndSwapInt来讲sizeCtl共享变量变为-1，占用该变量。在某个线程通过U.compareAndSwapInt方法设置了sizeCtl**之前和之后**进行了两次check，来检测table是否被初始化过了。

> 防止一个线程正初始化table但还没有初始化成功，而另一个线程竞争 sizeCtl 成功后发现 table 为 null，就会继续初始化。在当前线程完成初始化释放锁之后，如果之前的那个线程没有进行判断的话，就会再次初始化覆盖之前put的数据。

## get

计算出该记录的key值计算出该记录在 table 的索引值，如果不为null，则判断该位置上的第一个元素（链表头节点或者红黑树根节点），该 key 值是否匹配，匹配则直接返回该节点的值。

否则判断该节点的 hashcode 是否小于0，如果小于0，代表该位置上是一颗红黑树，则调用Node的finde()方法查找节点。否则就通过链表的方式来查询。

**同时为了保证 table 的可见性，使用 volatile 修饰**

**小于0也有两种情况，-1 和 -2**

当 eh = -1 时，代表该时间段正在扩容，数据被迁移时，旧的数组中的结点会被替换为`ForwardingNode`，Hash值置为-1。**且其内部维护了一个`nextTable`指向新的数组**，当我们发现需要查询的桶的Hash值为-1时，就会去新的数组中查找。

## put

1. 判断当前数组是否初始化，没有就初始化数组
2. 通过计算的 key 哈希值确定存放的位置，如果为空的话就直接添加，不为空就取出该节点
3. 如果取出的节点值为 MOVED，则表示当前数组正在扩容，则调用 **helpTransfer()** 让当前线程去帮助复制。
4. 否则，通过对当前节点使用 **synchronized** 来加锁，进行添加操作。
5. 判断节点哈希值，如果>=0，则说明是链表，则遍历链表，当遍历的节点与当前 key 值相同时，替换 value 值。如果找不到相同的就添加在**链表的尾部**
6. 如果 <0 ，则说明是树，调用 **putTreeVal** 方法将该元素添加进树内。
7. 添加完之后，判断当前位置有多少个节点，如果达到了八个以上的话，就**调用 treeifyBin 方法将链表转为红黑树，活着扩容。**

## 扩容  transfer

1. 通过cpu核心数量计算一个线程应该负责的桶数量，每个线程最少处理桶的数量是16.
2. 之后线程会来通过cas给总桶的数量减去任务桶数量，也就是领取任务。
3. 线程会锁住桶的头节点防止并发插入新的键值对，在完成桶的扩容后会在把头节点变成占位符表示桶处理结束了，其他的线程如果遇到桶的头节点是占位节点就会跳过。
4. 当线程处理完成后会回来继续领取任务。
5. 全部都结束之后会重新检查一遍数组是否有遗漏。

## size()

计算 size() 会调用  **sumCount()** 方法，统计的数据来源有两种，一种是来自计数盒子，也就是`CounterCell[]`这样的数组，`CounterCell`对象里面存放的是`volatile`类型的变量；另一种来自`baseCount`，当然也是`volatile`类型，保证线程安全。

> **`ConcurrentHashMap`提供了`baseCount、counterCells`两个辅助变量和一个`CounterCell`辅助内部类。**
>
> ```java
> @sun.misc.Contended static final class CounterCell {
>         volatile long value;
>         CounterCell(long x) { value = x; }
> }
> 
> //ConcurrentHashMap中元素个数,但返回的不一定是当前Map的真实元素个数。基于CAS无锁更新
> private transient volatile long baseCount;
> 
> private transient volatile CounterCell[] counterCells;
> ```
>
> **`size = baseCount + counterCells[0...n-1].value`**

**单线程修改计数时，用`baseCount`，一旦出现了多线程修改计数，那么后面就会抛弃`baseCount`，一直使用`CounterCell[]`计数。**

增加计数的方法就是 **addCount**。

通过CAS修改`baseCount`值，如果失败，就意味着存在并发，此时需要创建CounterCell[] 来保存每个线程添加的元素个数，之所以选择数组，是尽量让不同线程操作不同的`volatile`变量，以提高效率。







