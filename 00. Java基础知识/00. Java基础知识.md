# 面向对象三大特征

## 封装

隐藏对象的属性和实现细节，仅对外公开访问方法，控制在程序中属性的读和写的访问级别。

### 目的

增强安全性和简化编程，使用者不必了解具体的实现细节，而只要通过对外公开的访问方法，来使用类的成员。

### 要求

1. 把所有的属性私有化。
2. 对每个属性提供 `getter` 和 `setter` 方法。
3. 如果有一个带参的构造函数的话，那一定要写一个不带参的构造函数。
4. 建议重写 `toString` 方法，但这不是必须的。

## 继承

可以理解为，在一个现有类的基础之上，增加新的方法或**重写**已有方法，从而产生一个新类。

### 继承和权限

类成员访问修饰符与访问能力之间的关系：

|       类型       | private  |  无修饰  | protected | public |
| :--------------: | :------: | :------: | :-------: | :----: |
|      同一类      |  可访问  |  可访问  |  可访问   | 可访问 |
|  同一包中的子类  | 不可访问 |  可访问  |  可访问   | 可访问 |
| 同一包中的非子类 | 不可访问 |  可访问  |  可访问   | 可访问 |
|  不同包中的子类  | 不可访问 | 不可访问 |  可访问   | 可访问 |
| 不同包中的非子类 | 不可访问 | 不可访问 | 不可访问  | 可访问 |

### 优点

继承给我们的编程带来的好处就是对原有类的**复用**（重用）。除了继承之外，我们还可以使用**组合的方式**来复用类。

所谓组合就是把原有类定义为新类的一个属性，通过在新类中调用原有类的方法来实现复用。从抽象概念上来讲，**新定义类所代表的事物是原有类所代表的事物的一种**，那么这时**组合就是实现复用更好的选择。**

使用**继承**和**组合复用**原有的类，都是一种**增量式**的开发模式，这种方式带来的好处是不需要修改原有的代码，因此不会给原有代码带来新的 BUG，也不用因为对原有代码的修改而重新进行测试，这对我们的开发显然是有益的。因此，如果我们是在维护或者改造一个原有的系统或模块，尤其是对它们的了解不是很透彻的时候，就可以选择增量开发的模式，这不仅可以大大提高我们的开发效率，也可以规避由于对原有代码的修改而带来的风险。

## 多态

相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。继承是多态得以实现的基础。

### 实现的三个条件

1. 继承：在多态中必须存在有继承关系的子类和父类。
2. 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
3. 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。

### 实现方式

- 基于继承实现的多态

  主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。

- 基于接口实现的多态

  在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例，在运行时，根据对象引用的实际类型来执行对应的方法。

# 重载与重写

## 方法签名

方法名称+参数类型列表

一个类中两个方法的方法签名不能相同

## 重写

在**继承**情况下，子类中定义了与其父类中方法具有相同型构的新方法，就称为子类把父类的方法重写了。这是实现多态必须的步骤。

- final 、static 方法不能被重写
- 子类和父类在同一包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。

## 重载

指在**同一个类**中定义了一个以上具有相同名称，但是方法签名的方法。

**构造器可以被重载**。

# 泛型

## 定义

指在定义一个类、接口或者方法时可以指定类型参数。这个类型参数我们可以在使用类、接口或者方法时动态指定。

## 好处

- 编译时类型检查：当我们使用泛型时，加入向容器中存入非特定对象在编译阶段就会报错。假如不使用泛型，可以向容器中存入任意类型，容易出现类型转换异常。
- 不需要进行类型强制转换：使用泛型后容器可以记住存入容器中的对象的类型；
- 代码可读性提升：使用泛型后开发人员看一眼就知道容器中存放的是何种对象。

## 泛型擦除

**泛型擦除**是指Java中的泛型只在编译期有效，在运行期间会被删除。也就是说所有泛型参数在编译后都会被清除掉。

在编译器编译后，泛型的转换规则如下：

- List、List 擦除后的类型为 List；
- List[]、List[] 擦除后的类型为 List[]；
- List<? extends E>、List<? super E> 擦除后的类型为 List；
- List<T extends Serialzable & Cloneable> 擦除后类型为 List。

# 为什么说Java语言编译与解释并存

Java需要先经过编译成字节码文件，再通过jvm中的Java解释器来解释执行

# ==和equals

- 基本数据类型中，==比较的是值；引用类型中，==比较的是内存地址。
- equals不能用于基本数据类型，而只用于**引用数据类型**。当equals没有重写时，使用的是Object.equals()，比较的是**内存地址**。

# hashcode与equals

## hashcode

`hashcode()` 获得的是获取哈希值，确定对象在哈希表的索引位置。

## 为什么需要 hashcode()

hashcode()用于hashset中，当将一个数据放入hashset中时，首先判断hashcode是否相同，不相同则直接放进hashset，若存在相同，再使用equals判断是否相同，**减少了equals的次数**。

## 为什么重写 equals 需重写 hashcode()

- 使用 hashcode 进行提前校验，可以减少 equals() 次数
- **保证是同一对象**，如果重写了 equals ，而没有重写 hashcode()，会出现 equals() 相同，而 hashcode() 不相同的现象。

## 为什么不同的对象 hashcode 可能相同

哈希碰撞

# 包装类型

## 自动装箱/拆箱

- 装箱：将基本数据类型用他们的引用类型包装起来
- 拆箱：将包装类型转换为对应的基本数据类型

```java
Integer i = 10;
// 装箱，等价于
Integer i = Integer.valueOf(10);

int n = i;
// 拆箱，等价于
int n = i.intValue();
```

## 常量池

- Byte, Short, Integer, Long 这四种包装类型缓存了 [-128, 127] 的数据。
- Character 缓存了 [0, 127] 的数据。
- Boolean 直接返回 True Or False。

## 比较

整型包装类型的比较都是用 **equals()**，因为 [-128, 127] 都是缓存的数据，可以使用 `==` 进行判断，而除了这个范围的都需要重新在堆上创建对象，所以使用 `equals` 判断。

# String-Builder-Buffer

- String 内部 `private final byte[] value` 使用 final 关键字修饰，不可变。而 Builder 与 Buffer ，继承自 `AbstractStringBuilder`，内部 `privaet byte[] value` ，未使用 final 修饰，可变。
- String 不可变，线程安全。StringBuilder 对操作方法未加同步锁，线程不安全。StringBuffer 添加了同步锁，线程安全。
- 每次对 String 对象修改都会创建新的 String 对象。对 StringBuilder 和 StringBuffer 修改是对对象本身操作，使用 StringBuilder 性能比 StringBuffer 更好，但是有线程不安全的风险。

# 异常

所有异常都继承自**Throwable**，其中**Error**和**Exception**是他的子类，**Exception**分为受检异常和非受检异常。

# 代理

## 静态代理

静态代理主要是在编译器就将接口，实现类和代理类编译成了字节码文件。

## 动态代理

动态代理主要是在运行时期**动态**成成字节码文件，加载到JVM中。

### JDK动态代理

介绍它的使用：

1. 编写接口和它的实现类
2. 自定义InvocationHandler实现类，并重写Invoke()方法，在这个Invoke()方法里面就可以调用原方法，并且再原方法前后执行其它的操作。
3. 通过Proxy.newProxyInstance()方法，注入实现了 InvocationHandler 接口的对象，就能够创建动态代理对象。

```java
public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args);
}

// Proxy.newProxyInstance()
public static Object newProxyInstace(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h);
```

为什么只能支持实现了接口的类？

因为查看 JDK 生成的代理类，该代理类继承了 **Proxy** 类，因为 Java 是单继承的类，不支持多继承，所以只能实现接口。

### CGLIB动态代理

JDK动态代理只能代理**实现了接口的类**或接口。

介绍它的使用：

1. 定义**一个类**
2. 自定义实现 MethodInterceptor 的类，并重写intercept()方法，在该方法里面对原方法进行增强。
3. 最后通过Enhancer类的create()创建代理类

# 异常

![img](..\img\Java异常类层次结构图2.png)
